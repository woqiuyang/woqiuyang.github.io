---
title: 阿里巴巴开发规范.md
date: 2020-5-13 11:13:39
cover: https://blog-1258707945.cos.ap-guangzhou.myqcloud.com/img/20220513111454.png
tags:
- note
---

>boolean不要以is开头，不然get方法就会出问题。

>包名统一用单数形式。

>使用完整的单词表达。

>禁止出现魔法值，任何直接出现在代码中的字符串都是魔法值

>使用long类型，必需使用大L,避免i1不分

>equals容易出现空指针异常
正确写法
＂sbdl＂.equals=object
推荐使用jdk7工具类
equals(a，b)

>Integer使用static生成-128到127的之间所以的数字，所以128=128等于false
所以所有的包装类都要用equals比较

>任何货币金额，都以最小金额单位且整形来存储

>浮点型数据，基本类型不能用==，包装类型不能用equals，1.0=1.00为false，因为精度不同，应该使用compareTo

>禁止在bigDicmal中传入double，应该使用valueOf,实现原理是toString

>所有的对象pojo都使用包装类型，不然有默认值
所有的局部变量都使用基本类型

>pojo类必须写toString方法，如果有继承，要super.toString

>日期格式化，new SImpleDateFormat("yyyy-MM-dd HH:mm:ss")
大写M 月份
小写M 分钟
24小时是大写H
12小时是小写的h

>获取当前毫秒数，System.currentTimeMillis()，底层使用的native方法
精确计时使用Instant类，精确到纳秒

>不要在程序中写死一年的天数，应该使用LocalDate.now().lengthOfYear()获取今年天数

>只要重写了equals，就要重写hashCode方法,Set和Map的key依据hashCode判断,
String重写的hashCode和equals方法，所以可以将String对象作为key来使用

>判断集合是否为空，调用isEmpty1方法,因为不是遍历实现的size==0

>使用stream流中的Collectors的toMap时，一定要使用含有参数类型BinaryOperator，参数值为mergeFunction的方法，否则出现相同的key，会抛出IllegalStateException
Collectors.toMap(key,value,(v1,v2)->v1)
> toMap时，value也不能为空，所以在转换之前要做filter过滤
> list.stream().filter(t->StringUtils.isNotBlank(t.getName)).collect(Collectors.toMap(t.getId,t.getName,(v1,v2)->v1))

>ArrayList的subList不可用强转ArrayList,因为subList返回的内部类是SubList是ArrayList的视图，对于subList的操作都会返回到原ArrayList上

>使用Map中的keySet/values/entrySet返回集合对象时，不可用对其添加元素操作，否则抛出UnsupportedOperationException

>在subList场景中，对父类集合的增加和删除，均会导致子列表的遍历，增加，删除产生ConcurrentModificationException

>集合转换数据的时候，list.toArray要指定参数，list.toArray(new String[0]),不然返回的object对象再转换，会出现转换异常，toArray的带参方法，length=0时，动态创建和size相同的数组

>使用ArrayList.addAll底层实现还是toArray,所以使用之前要判断参数是否为空

>不要在foreach中进行元素的add/remove操作。remove元素请使用Iterator，如果是并发操作请对Iterator对象加锁

>获取单例对象要保证线程安全

>创建线程或线程池，请指定有意义的线程名字，使用自定义线程工厂实现ThreadFactory，
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com/img/20220513160147.png)

>线程资源必须通过线程池提供，通过ThreadPoolExecutor方法创建，

>SimpleDateFormat是线程不安全的类，不要定义为static变量,在jkd8应用中，使用Instant代替Date,LocalDateTime代替Calendar,使用DateTimeFormatter代替SimpleDateFormat

>必须回收自定义的ThreadLocal变量，在线程池场景下，会造成内存泄漏，建议使用
```java
aThreadLocal.set(userInfo)
        try{
            
        }finally(){
        aThreadLocal.remove()
        }
```

>高并发中，能锁区块就不要锁整个方法，能用对象锁就不要用类锁

>对多个资源，数据库表，对象同时加锁时，注意保持一致的加锁顺序，否则可能会造成死锁

>使用阻塞等待获取锁的过程中，必须在try代码块之外，并且加锁方法与try之间没有任何可能抛出的异常，避免加锁成功后，在finally无法解锁
```java
new Lock();
        lock.lock();
        try{

        }finally{
        lock.unlock()
        }
```

>在尝试机制获取锁中，进入业务代码块之前，必须先判断当前线程是否持有锁，锁的释放规则与锁的阻塞等待方法相同
```java
Lock lock=new aLock();
        boolean isLocked=lock.tryLock();
        if(isLocked){
        try{
        doSomething();
        }finally{
        lock.unlock();
        }
        }
```

>并发修改时，更新同一条记录，避免更新丢失，需要加锁，要么在应用层面加锁，要么在缓存加锁，要么在数据库使用乐观锁version,访问冲突概率小于20%，使用乐观锁，否则使用悲观锁。
> 乐观锁的重试次数不得小于3次。

>多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中一个没有捕获抛出异常，其他任务便会自动停止运行，使用ScheduledExecutorService则没有这个问题。

**反**
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com/img/20220513163237.png)

**正**
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com/img/20220513163142.png)
>资金相关的信息，使用悲观锁，乐观锁在获取锁的同时完成了更新操作，检验逻辑容易出现漏洞，另外乐观锁对锁冲突的解决策略有较复杂的要求，处理不当容易造成系统压力，
> 悲观锁原则：一锁，二判，三更新，四释放

>在switch块中，每一个case都要通过continue/break/return来控制
> 必须包含一个default放在语句最后，即使他什么代码也没有

> 在switch块之前判断param是否为null，不然default方法也不会执行，抛出空指针异常

> 三目运算符 1:2中，注意1:2的类型对齐时，可能会抛出空指针问题
> 自动拆箱的触发场景
> 1和2的值只要有一个是原始类型
> 1和2的值类型不一致，会强制拆箱升级
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com/img/20220513164033.png)

>高并发场景中，避免使用"等于"判断作为中断或退出条件，建议使用大于或小于
> 比如：判断剩余商品数量等于0，终止发放商品，但是并发处理导致奖品数量瞬间变成了负数

>Api规范
> 协议:生产环境必须使用HTTPS
> 路径:使用名词，推荐使用复数，请求方法已经表达了动作的含义,不能使用大写url，使用下环线分割，禁止携带表示请求内容的后缀，比如.json,.xml
> 请求方法：Get:取出资源 POST:新建资源 PUT:更新资源 DELETE: 删除资源
> 请求内容: url参数必须无敏感信息或加密,body里带的参数必须设置Content-Type
> 响应体:响应体body可以防止多种数据类型，由Content-Type头来确定

>前后端数据列表的接口返回，如果为空，返回空数组或空集合，避免前端很多琐碎的null判断

>需要使用长整数一律用String，使用Long类型，js会自动转换成number类型(双浮点),会出现精度丢失,比如订单号，不要用long类型

>http请求通过url传参，不能超过2048字节

>http请求通过body传参，必须控制长度，nginx默认1mb，tomcat默认2mb

>在分页场景中，输入的参数小于1则显示第一页，参数大于总页数则返回最后一页

>正则表达式利用预编译功能，加快匹配速度，指不要在方法体内定义规则 
> 错误写法：Pattern pattern = Pattern.compile("规则)

>避免使用Apache Beanutils，可以使用Spring的BeanUtils(都是浅拷贝)

>获取随机值，直接使用Random对象的nextInt和nextLong方法

>可以通过预检查规避的RuntimeException不应该通过catch处理
正例：if(a != null)
反例：try{(a.getA)} catch(NullPointException e)

>不要在finally块中使用return，try块中的return执行完成后，并不会马上返回，而是继续执行finally块，再返回

>rpc调用，或者二方包调用时，捕获异常必须使用Throwable类进行拦截,在catch块中判断具体接受的异常

>不可用直接使用日志系统(log4j,Logback)的api，而应该使用slf4j,JCL面门框架的Api,有利于各个类的日志统一处理

>所有日志至少保存15天，对于当天日志，以应用名.log保存，保存在home/admin/应用名/logs/ 目录下,
>过往日志格式为:logName.log.保存日期 日期格式 yyyy-MM-dd

>根据国家法律规定，网络运行状态，网络安全事件，个人敏感信息等操作日志，保存不少于六个月，并且网络多机备份

>扩展日志命令方式appName_logType_logName.log

>日志输出时，使用占位符拼接,内部实现的是StringBuilder
> logger.debug("id = {} and symbol = {}",id,symbol);

>对于trace/debug/info级别的日志输出,必须先判断开关
```java
if(logger.isDebugEnable()){
    logger.debug("id = {}",id)
        }
```

>禁止使用System.out或System.err输出日志或者使用e.printStackTrace打印异常堆栈

>打印日志，直接调用toString方法，不要通过JSONObject.toJsonString，不然会调用get方法

>单元测试必须遵守AIR，自动化，独立性，可重复

>单元测试之间不能先后调用,单元测试是可以重复执行的

>用户个人页面必须权限校验

>用户敏感数据，必须进行数据脱敏例如 显示 130****4320,防止泄漏

>用户请求传入的任何参数必须做有效性验证
>page size 过大导致内存溢出
>恶意的order by 导致数据库慢查询 
> 缓存击穿
> SSRF，既伪造一个服务端请求，攻击者利用系统的某些接口，通过这个接口向目标系统发情攻击
> 任意重定向 
> SQL注入，Shell注入，反序列化注入
> 正则输入源串拒接服务ReDoS

>禁止向HTML页面输出未经安全过滤或者正确转义的用户数据

>表单，AJAX必须执行CSRF安全验证
> 跨站请求伪造是一类常见的编程漏洞，对于存在csrf的网站，攻击者可以实现通过构造好的url，只有受害者用户一访问，后台便可以在用户不知情的情况下修改用户数据
> 可以理解为攻击者盗用了你的身份，然后以你的名义发起恶意请求，这个请求对于服务器来说完全合法

>url外部重定向传入的地址，必须执行白名单过滤

>表示是或者否，必须使用is_xxx命名，类型是unsigned tinyint

>任何字段如果为非负数，必须是unsigned

>表名，字段名都必须使用小写，数据库修改字段的代价很大，MySQL在Windows下是不区分大小写的，但是在Linux下区分大小写，所有不允许有大小写

>表明使用用复数形式

>主键索引名为pk_字段名，唯一索引为uk_字段名,普通索引为idx_字段名

>小数类型一律用decimal,禁止使用float和double
如果您要遵守公认会计原则(GAAP)规则，则货币栏必须至少包含4位小数，以确保舍入值不超过$0.01。 在这种情况下，应该定义具有4位小数的列，如下所示：
amount DECIMAL(19,4),第一个参数是最大位数，第二个参数是小数位数
> 如果存储范围超过decimal的范围，建议将数据拆成证书和小数分开存储

>如果存储的字符串长度几乎相等，使用char定长字符串类型

>varchar是可变长字符串，不预先分配内存空间，长度不要超过5000，如果长度大于这个值，使用text类型，单独出来一张表，用主键来对应，避免影响其他字段的索引值

>表必备三字段，id，create_time,update_time
> id为主键，类型为bigint unsigned，单表时自增，步长为1，
> create_time,update_time类型均为datetime类型,

>业务上具有唯一特性的字段，即使是组合字段，也必须建立唯一索引
> 唯一索引不会影响insert速度，但是提高查找速度是明显的，
> 另外，即时在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必有脏数据产生

>超过三个表禁止join，需要join的字段，数据类型必须保持一致，
> 多表关联查询时,被关联的字段要有索引
> 即时双表join,也要注意表索引

>在varchar字段建立索引时，必须指定索引长度，没必要全字段建立索引，根据实际的文本区分度决定索引长度

>页面搜索，严禁左模糊和全模糊，如果需要请走搜索引擎，索引文件根据最左匹配原则，如果左边的值未确定，那么无法使用此索引

>count(*)会统计为列值为null的行,count(列名)不会

>count(distinct 字段)计算该列除null之外的不重复行

>null和任何值比较都是null，而不是true或false

>如果某一列的值全为空，使用IFNULL(count(列名))或者IFNULL(SUM(列名)),避免空指针
> 使用ISNULL判断是否为NULL，ISNULL(列名)

>若分页查询，count为0,应该直接返回，避免执行后面的分页语句

>不得使用外键和级联

>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性

>数据订正，要先select，避免出现误删除

>对于数据库中多个表的查询，都需要在列名前加表的别名

>在表查询中，一律不使用*

>不要使用resultCLass当返回参数，即使所有的属性名与数据库字段对应，也需要定义resultMap，方便配置映射关系，使字段与DO类解耦

>不允许直接拿HashMap和HashTable作为查询结果输出
> 某同学为了避免写一个resultMap,直接使用HashMap接受数据库返回结果，结果出现本地把bigint转换成long值，而由于线上数据库版本不一样，解析成BigInteger，出现问题

>
