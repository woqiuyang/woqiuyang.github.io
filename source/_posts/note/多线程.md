---
title: 常见多线程使用记录
date: 2020-5-26 22:55:20
cover: https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220526225609.png
tags:
- note
---
# 起始
一个高并发系统，最优秀的响应时间在200ms之内
在调用两个service串行调用的情况下，响应已经到了400ms

# Callable
想要获取一个有返回值的线程，使用Callable

无法通过new Thread的方式创建Callable
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220526231027.png)

## 使用FutureTask
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220526231313.png)
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220526231609.png)
## 使用get方式获取
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220526233057.png)
响应时间-200ms
## 问题
tomcat处理线程默认是200个，如果没有get到返回值，会导致阻塞
解决方案，使用Servlet3.0异步请求
# Servlet3.0
异步直接返回Callable,return callable会回调
Tomcat主线程接近0ms，子线程耗时300ms
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220526234543.png)
## 原理
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220526234920.png)
## 问题
多线程调用多个接口，造成大量的并发
解决方案
使用批量接口，定时任务，或者CompletableFuture
# 定时任务加批量接口
将请求装到队列中，每隔10ms批量调用，包装成list返回，通过分布式id，分发给对应的客户端
## CountDownLatch
模拟1w个并发
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220527001708.png)

## 定时线程池
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220527002334.png)

## 阻塞队列
包装请求，放入唯一id，请求内容，CompletableFuture
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220527002454.png)

## 封装数据
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220527002728.png)
## 定时任务
 如果队列为空，直接return
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220527003927.png)
 接口的参数包装
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220527004024.png)
 调用批量接口
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220527004254.png)
## 测试单个调用的性能差距
![](https://blog-1258707945.cos.ap-guangzhou.myqcloud.com//blog/20220527004551.png)
