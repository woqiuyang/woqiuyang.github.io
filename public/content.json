{"meta":{"title":"谢谢你，因为有你，温暖了四季","subtitle":"qaqaq","description":"哥，别说了，我都流汗了","author":"QY","url":"http://example.com","root":"/"},"pages":[{"title":"分類","date":"2018-01-04T16:00:00.000Z","updated":"2022-08-12T16:13:29.692Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"標籤","date":"2018-01-04T16:00:00.000Z","updated":"2022-08-12T16:13:29.692Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"1","slug":"code/1","date":"2022-08-12T06:31:02.000Z","updated":"2022-08-12T16:13:29.688Z","comments":true,"path":"2022/08/12/code/1/","link":"","permalink":"http://example.com/2022/08/12/code/1/","excerpt":"","text":"按天批量写入123456789Date d1= DateUtils.parseDate(dateBegin,&quot;yyyyMMdd&quot;);Date d2= DateUtils.parseDate(dateEnd,&quot;yyyyMMdd&quot;);if(d1.after(d2) )&#123; return new BaseResult(BaseMessage.FAILED.getCode(),&quot;开始时间不可大于结束时间&quot;,&quot;&quot;);&#125;while(d2.after(d1)||d1.equals(d2))&#123; liquidateFundFlowService.refreshFundFLowBizInfo(d1); d1=DateUtils.addDays(d1,1);&#125; 1234567891011121314151617181920tranDate = DateUtils.truncate(tranDate, Calendar.DATE);Date tranDateEnd = DateUtils.addDays(tranDate,1);Long maxId = null;while (true)&#123; PageHelper.offsetPage(0, 1000, false); LiquidateBizFlowExample example = new LiquidateBizFlowExample(); LiquidateBizFlowExample.Criteria criteria = example.createCriteria() .andDeleteFlagEqualTo(DeleteFlag.ENABLE.getIndex()) .andSysCtimeGreaterThan(tranDate) .andSysCtimeLessThan(tranDateEnd) .andOperateTypeEqualTo(LiquidateOperateType.FUND.getCode()); example.setOrderByClause(&quot;id&quot;); if (null != maxId)&#123; criteria.andIdGreaterThan(maxId); &#125; List&lt;LiquidateBizFlow&gt; liquidateBizFlows = liquidateBizFlowMapper.selectByExample(example); if (CollectionUtils.isEmpty(liquidateBizFlows))&#123; break; &#125; maxId = liquidateBizFlows.get(liquidateBizFlows.size() - 1).getId();","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"}]},{"title":"IDEA暂存文件","slug":"pulgin/IDEA暂存文件","date":"2022-06-28T07:23:08.000Z","updated":"2022-08-12T16:13:29.691Z","comments":true,"path":"2022/06/28/pulgin/IDEA暂存文件/","link":"","permalink":"http://example.com/2022/06/28/pulgin/IDEA%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6/","excerpt":"","text":"从主菜单中，选择文件 | 新 | 暂存文件或按Ctrl+Alt+Shift+Inserthttps://www.jetbrains.com/help/webstorm/scratches.html#create-scratch-file","categories":[],"tags":[{"name":"暂存文件","slug":"暂存文件","permalink":"http://example.com/tags/%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6/"}]},{"title":"mvvm原理","slug":"project/1.mvvm原理","date":"2022-06-27T15:13:09.000Z","updated":"2022-08-12T16:13:29.690Z","comments":true,"path":"2022/06/27/project/1.mvvm原理/","link":"","permalink":"http://example.com/2022/06/27/project/1.mvvm%E5%8E%9F%E7%90%86/","excerpt":"","text":"mvvm data就是M视图层el就是V视图层new Vue()得到的vm实例，提供了双向绑定的能力 指令 v-bind v-onjquery写法 v-on加点击事件 es6语法 es6传参 简写 v-model数据单向绑定 双向绑定","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"IDEA忽略配置文件","slug":"config/Idea忽略配置文件","date":"2022-06-27T09:47:59.000Z","updated":"2022-08-12T16:13:29.688Z","comments":true,"path":"2022/06/27/config/Idea忽略配置文件/","link":"","permalink":"http://example.com/2022/06/27/config/Idea%E5%BF%BD%E7%95%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"Move to Another Changelist 将选中的文件转移到其他的 Change list 中。 Change list 是一个重要的概念，这里需要进行重点说明。很多时候，我们开发一个项目同时并发的任务可能有很多，每个任务涉及到的文件可能都是基于业务来讲的。 所以就会存在一个这样的情况：我改了 30 个文件，其中 15 个文件是属于订单问题，剩下 15 个是会员问题，那我希望提交代码的时候是根据业务区分这些文件的， 这样我填写 Commit Message 是好描述的，同时在文件多的情况下，我也好区分这些要提交的文件业务模块。 所以我一般会把属于订单的 15 个文件转移到其他的 Change list中，先把专注点集中在 15 个会员问题的文件，先提交会员问题的 Change list，然后在提交订单会员的 Change list。 我个人还有一种用法是把一些文件暂时不提交的文件转移到一个我指定的 Change list，等后面我觉得有必要提交了，再做提交操作，这样这些文件就不会干扰我当前修改的文件提交。 总结下 Change list 的功能就是为了让你更好地管理你的版本控制文件，让你的专注点得到更好的集中，从而提供效率。","categories":[],"tags":[{"name":"config","slug":"config","permalink":"http://example.com/tags/config/"}]},{"title":"绩效考核系统","slug":"task/绩效考核系统","date":"2022-06-21T03:05:47.000Z","updated":"2022-08-13T07:20:53.807Z","comments":true,"path":"2022/06/21/task/绩效考核系统/","link":"","permalink":"http://example.com/2022/06/21/task/%E7%BB%A9%E6%95%88%E8%80%83%E6%A0%B8%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"360干部考核系统-wehr主要功能分为问卷管理，问卷填写，评估管理和结果报告 https://wesure.coding.inwesure.com/p/g010/d/wehr/git 使用使用分支 dev 两个项目端口都是9200，改wehr为9201，同时修改grpc端口为59201 绩效考核系统-assess分为绩效目标和绩效考核，绩效考核分为自评、初评、复评、星级报表、评估结果展示、评估配置 https://wesure.coding.inwesure.com/p/g010/d/assess/git 使用使用分支 dev 流程新建周期(assess_period) ​ -目标人员填写(assess_target_persons) id = period_id ​ -评估主实体(assess_header) period_code= period_code 问题发起目标，还没有导入填写目标人员，发起成功(好像又不用改动了)解决 1234567891011121314//查询当前周期信息AssessPeriod assessPeriodDb = assessPeriodService.selectByPrimaryKey(assessPeriod.getId());if (null == assessPeriodDb)&#123; return new BaseResult(BaseMessage.FAILED,&quot;考核周期不存在&quot;,null);&#125;AssessHeaderExample assessHeaderExample = new AssessHeaderExample();assessHeaderExample.createCriteria() .andIsDelEqualTo((byte) 0) .andPeriodCodeEqualTo(assessPeriodDb.getPeriodCode());List&lt;AssessHeader&gt; assessHeaders = assessHeaderService.selectByExample(assessHeaderExample);if (CollectionUtils.isEmpty(assessHeaders))&#123; return new BaseResult(BaseMessage.FAILED,&quot;请先配置评估人员&quot;,null);&#125; 1period_status &#x27;状态 0未发起 1已发起 2已结束&#x27;, 前端网页https://wesure.coding.inwesure.com/p/g010/d/assess-web/git 使用使用分支 develop http://localhost:9008/ 配置本地网关vue.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155module.exports = &#123; // app部署路径 publicPath: &#x27;/&#x27;, // build目录 outputDir: &#x27;dist&#x27;, devServer: &#123; clientLogLevel: &#x27;warning&#x27;, historyApiFallback: true, hot: true, compress: true, host: &#x27;0.0.0.0&#x27;, port: 9008, open: false, overlay: &#123; warnings: false, errors: true &#125;, watchOptions: &#123; poll: false &#125;, proxy: &#123; // 系统业务接口 &#x27;/wofNidGenerator/getNids&#x27;: &#123; target: &#x27;http://upmsapi.sit.com:10020&#x27;, changeOrigin: true, secure: false, headers: &#123; &#x27;X-WESURE-ENAME&#x27;: &#x27;v_linzlzhao&#x27; &#125; &#125;, // 自定义页面接口 &#x27;/upmsapi/forward_service/&#x27;: &#123; target: &#x27;http://upmsapi.sit.com:10020&#x27;, // sit changeOrigin: true, secure: false &#125;, &#x27;/manage/formappdata/&#x27;: &#123; target: &#x27;http://10.0.32.65:80&#x27;, changeOrigin: true, secure: false &#125;, &#x27;/manage/customapp/&#x27;: &#123; target: &#x27;http://10.0.32.65:80&#x27;, // target: &#x27;http://10.98.163.34:8001&#x27;, changeOrigin: true, secure: false &#125;, &#x27;/manage/processappdata/&#x27;: &#123; target: &#x27;http://10.0.32.65:80&#x27;, changeOrigin: true, secure: false &#125;, &#x27;/workflow/workflow_procIns/getDataByUrl&#x27;: &#123; target: &#x27;http://upmsapi.sit.com:10020&#x27;, // target: &#x27;http://10.98.163.22:10020&#x27;, changeOrigin: true, secure: false, headers: &#123; &#x27;X-WESURE-ENAME&#x27;: &#x27;v_linzlzhao&#x27; &#125; &#125;, &#x27;/workflow/&#x27;: &#123; target: &#x27;http://10.0.32.179:7001&#x27;, changeOrigin: true, secure: false, headers: &#123; &#x27;X-WESURE-ENAME&#x27;: &#x27;v_linzlzhao&#x27; &#125; &#125;, // 系统业务接口 &#x27;/assess/result/&#x27;: &#123; // target: &#x27;http://10.98.163.68:9200&#x27;, // 淼哥 target: &#x27;http://10.98.164.181:9200&#x27;, // sit // target: &#x27;http://10.98.164.143:9200&#x27;, // sit changeOrigin: true, secure: false // headers: &#123; // &#x27;X-WESURE-ENAME&#x27;: &#x27;raymcheng&#x27; // &#125; &#125;, &#x27;/public/pbc&#x27;: &#123; // target: &#x27;http://10.98.163.68:9200&#x27;, // 淼哥 // target: &#x27;http://10.98.163.130:9200&#x27;, // 东哥 target: &#x27;http://10.98.164.181:9200&#x27;, // 一路 // target: &#x27;http://10.98.163.130:9200&#x27;, // 景康 // target: &#x27;http://10.0.22.240:80&#x27;, // sit changeOrigin: true, secure: false &#125;, &#x27;/public/&#x27;: &#123; // target: &#x27;http://10.98.163.68:9200&#x27;, // 淼哥 // target: &#x27;http://10.98.163.130:9200&#x27;, // 东哥 target: &#x27;http://10.98.164.181:9200&#x27;, // 一路 // target: &#x27;http://10.98.163.130:9200&#x27;, // 景康 // target: &#x27;http://10.0.22.240:80&#x27;, // sit changeOrigin: true, secure: false &#125;, &#x27;/assess/pbc/&#x27;: &#123; // target: &#x27;http://10.98.163.68:9200&#x27;, // 淼哥 // target: &#x27;http://10.98.163.130:9200&#x27;, // 东哥 target: &#x27;http://10.98.164.181:9200&#x27;, // 一路 // target: &#x27;http://10.98.163.130:9200&#x27;, // 景康 // target: &#x27;http://10.0.22.240:80&#x27;, // sit changeOrigin: true, secure: false, headers: &#123; &#x27;X-WESURE-ENAME&#x27;: &#x27;yeelusun&#x27; &#125; &#125;, &#x27;/assess/&#x27;: &#123; // target: &#x27;http://10.98.163.68:9200&#x27;, // 淼哥 // target: &#x27;http://10.98.163.130:9200&#x27;, // 东哥 target: &#x27;http://10.98.164.181:9201&#x27;, // 一路 // target: &#x27;http://10.0.64.179:9200&#x27;, // sit changeOrigin: true, secure: false, headers: &#123; &#x27;X-WESURE-ENAME&#x27;: &#x27;jackieyang&#x27; &#125; &#125;, &#x27;/hr/&#x27;: &#123; // target: &#x27;http://10.98.163.68:9200&#x27;, // 淼哥 // target: &#x27;http://10.98.163.33:9200&#x27;, // 东哥 // target: &#x27;http://10.98.164.197:9200&#x27;, // 一路 target: &#x27;http://10.98.164.181:9201&#x27;, // 一路 // target: &#x27;http://10.0.64.179:9200&#x27;, // sit changeOrigin: true, secure: false // headers: &#123; // &#x27;X-WESURE-ENAME&#x27;: &#x27;raymcheng&#x27; // &#125; &#125;, // 系统业务接口 &#x27;/manage/&#x27;: &#123; target: &#x27;http://10.0.32.14:7001&#x27;, changeOrigin: true, secure: false &#125;, // 人员和组织接口, 针对/api/v2/user/search和/api/v2/organization/search，这2个接口没用到的可以不配 &#x27;/api/&#x27;: &#123; target: &#x27;http://upmsapi.sit.com:10020&#x27;, // target: &#x27;http://upmsapi.dev.com:10020&#x27;, changeOrigin: true, secure: false &#125;, // 统一网关接口 &#x27;/SolomonService/&#x27;: &#123; target: &#x27;http://upmsapi.sit.com:10020&#x27;, // target: &#x27;http://upmsapi.dev.com:10020&#x27;, changeOrigin: true &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"task","slug":"task","permalink":"http://example.com/tags/task/"}]},{"title":"GenerateAllSetter Postfix Completion","slug":"pulgin/GenerateAllSetter Postfix Completion","date":"2022-06-20T12:13:43.000Z","updated":"2022-08-12T16:13:29.691Z","comments":true,"path":"2022/06/20/pulgin/GenerateAllSetter Postfix Completion/","link":"","permalink":"http://example.com/2022/06/20/pulgin/GenerateAllSetter%20Postfix%20Completion/","excerpt":"","text":"生成 set 1foo.allset 根据一段含有源对象（a）/目标对象（b）的 b.setXxx(a.getXxx()) 方法代码生成所有 set 方法以快速实现对象转换 12345678910111213public void usage05() &#123; // 用法5, 将 src 的数据赋值给 dest, 常用于两个不同类直接进行 convert(需字段名称相同), 通过 postfix Foo src = new Foo(); Foo dest = new Foo(); // 取消下面的注释, 光标位于 convert 后面, 按下 Tab 键// dest.setTestInt(src.getTestInt());.convert // 即可得到下面结果 dest.setTestInt(src.getTestInt()); dest.setTestLong(src.getTestLong()); dest.setTestFloat(src.getTestFloat()); dest.setTestDouble(src.getTestDouble()); dest.setTestBoolean(src.getTestBoolean());&#125;","categories":[],"tags":[{"name":"插件","slug":"插件","permalink":"http://example.com/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"MySql数据库单表查询","slug":"note/MySql数据库单表查询","date":"2022-06-20T11:39:05.000Z","updated":"2022-08-12T16:13:29.689Z","comments":true,"path":"2022/06/20/note/MySql数据库单表查询/","link":"","permalink":"http://example.com/2022/06/20/note/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"很多高性能的应用都会对关联查询进行分解。简单地，可以对每个表进行一次单表查询，然后将结果在应用程序中进行关联。例如，下面这个查询： 1234select * from tag join tag_post on tag_post.tag_id=tag.id join post on tag_post.post_id=post.id where tag.tag=&#x27;mysql&#x27;; 可以分解成下面这些查询来代替： 123Select * from tag where tag=&#x27;mysql&#x27;;Select * from tag_post where tag_id=1234;Select * from post where id in(123,456,567,9989,8909); 事实上，用分解关联查询的方式重构查询具有如下优势：（高并发、高性能的应用中，一般建议使用单表查询） 让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。另外对于 MySQL 的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。 将查询分解后，执行单个查询可以减少锁的竞争。 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。 查询本身效率也可能会有所提升。 可以减少冗余记录的查询。 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用 MySQL 的嵌套环关联，某些场景哈希关联的效率更高很多。 单表查询有利于后期数据量大了分库分表，如果联合查询的话，一旦分库，原来的 sql 都需要改动。 上次看到某个 CTO 技术分享，公司规定底层禁止用 join 联合查询。数据大的时候确实慢。 联合查询或许确实快，但是 mysql 的资源通常比程序代码的资源紧张的多。","categories":[],"tags":[{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]},{"title":"待学清单","slug":"note/待学清单","date":"2022-06-20T07:57:40.000Z","updated":"2022-08-13T07:50:12.452Z","comments":true,"path":"2022/06/20/note/待学清单/","link":"","permalink":"http://example.com/2022/06/20/note/%E5%BE%85%E5%AD%A6%E6%B8%85%E5%8D%95/","excerpt":"","text":"问题排查能力blockingQueue []redismongotidb","categories":[],"tags":[]},{"title":"MyBatisCodeHelper-Pro","slug":"pulgin/MyBatisCodeHelper-Pro","date":"2022-06-14T03:19:40.000Z","updated":"2022-08-12T16:13:29.691Z","comments":true,"path":"2022/06/14/pulgin/MyBatisCodeHelper-Pro/","link":"","permalink":"http://example.com/2022/06/14/pulgin/MyBatisCodeHelper-Pro/","excerpt":"","text":"配置model不被覆盖 生成单元测试 xml生成resultMap","categories":[],"tags":[{"name":"IDEA插件","slug":"IDEA插件","permalink":"http://example.com/tags/IDEA%E6%8F%92%E4%BB%B6/"}]},{"title":"maven","slug":"config/maven","date":"2022-06-10T02:34:00.000Z","updated":"2022-08-12T16:13:29.688Z","comments":true,"path":"2022/06/10/config/maven/","link":"","permalink":"http://example.com/2022/06/10/config/maven/","excerpt":"","text":"命令行跳过测试打包1mvn clean install -Dmaven.test.skip=true 明明有本地文件，idea却找不到包在idea中使用maven时常常出现配置好pom依赖后，怎么reimport都无法下载jar包。解决方法：在Maven窗口中打开mvn命令，输入更新不完整依赖命令： 1mvn -U idea:idea 运行，就可以下载没有的jar包。 maven红色波浪线通过上面的命令jar包已经导入了成功也不能消除（reimport也不行，不过可以正常使用），可以先将带红色波浪线的依赖剪切掉，reimport一下，再将依赖粘贴回去，完美解决。 maven查找网站https://mvn.coderead.cn/","categories":[],"tags":[{"name":"config","slug":"config","permalink":"http://example.com/tags/config/"}]},{"title":"CompletableFuture常用记录","slug":"note/CompletableFuture","date":"2020-05-26T16:52:44.000Z","updated":"2022-08-12T16:13:29.689Z","comments":true,"path":"2020/05/27/note/CompletableFuture/","link":"","permalink":"http://example.com/2020/05/27/note/CompletableFuture/","excerpt":"","text":"工具类123456789101112131415161718192021public class SmallTool &#123; public static void sleepMillis(Integer millis)&#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void printTimeAndThread(String tag)&#123; String result = new StringJoiner(&quot;\\t|\\t&quot;) .add(String.valueOf(System.currentTimeMillis())) .add(String.valueOf(Thread.currentThread().getId())) .add(Thread.currentThread().getName()) .add(tag) .toString(); System.out.println(result); &#125;&#125; 例子一1234567891011121314151617public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;我进了饭堂&quot;); SmallTool.printTimeAndThread(&quot;我点了滑鸡饭&quot;); // supplyAsync是java的函数式编程接口，叫提供者者， // 没有入参，只有一个返回值,因为我们返回了字符串，所以CompletableFuture的泛型是String CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;厨师炒菜&quot;); SmallTool.sleepMillis(200); SmallTool.printTimeAndThread(&quot;厨师打饭&quot;); SmallTool.sleepMillis(100); return &quot;滑鸡 + 饭 好了&quot;; &#125;); SmallTool.printTimeAndThread(&quot;我在打王者&quot;); // join等待任务执行结束，返回任务结果 SmallTool.printTimeAndThread(String.format(&quot;%s,小白开吃&quot;,stringCompletableFuture.join()));&#125; 输出结果 例子二一般来说，打饭这件事情是服务员干的 123456789101112131415161718192021public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;我进了饭堂&quot;); SmallTool.printTimeAndThread(&quot;我点了滑鸡饭&quot;); // supplyAsync是java的函数式编程接口，叫提供者者， // 没有入参，只有一个返回值,因为我们返回了字符串，所以CompletableFuture的泛型是String CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;厨师炒菜&quot;); SmallTool.sleepMillis(200); return &quot;滑鸡&quot;; // thenCompose要求我们传入一个Function接口，传入参数T，经过转换后返回R // 将前面任务的结果返回给下一个任务 &#125;).thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;服务员打饭&quot;); SmallTool.sleepMillis(100); return s+&quot;米饭&quot;; &#125;)); SmallTool.printTimeAndThread(&quot;我在打王者&quot;); // join等待任务执行结束，返回任务结果 SmallTool.printTimeAndThread(String.format(&quot;%s,小白开吃&quot;,stringCompletableFuture.join()));&#125; 例子三服务员还没做饭，要求厨师炒菜的时候，服务员同时蒸饭,要求炒菜和蒸饭同时返回，才能执行炒菜 1234567891011121314151617181920212223 public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;我进了饭堂&quot;); SmallTool.printTimeAndThread(&quot;我点了滑鸡饭&quot;); // supplyAsync是java的函数式编程接口，叫提供者者， // 没有入参，只有一个返回值,因为我们返回了字符串，所以CompletableFuture的泛型是String CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;厨师炒菜&quot;); SmallTool.sleepMillis(200); return &quot;滑鸡&quot;; &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;服务员蒸饭&quot;); SmallTool.sleepMillis(300); return &quot;米饭&quot;; &#125;),(s, s2) -&gt; &#123; SmallTool.printTimeAndThread(&quot;服务员打饭&quot;); SmallTool.sleepMillis(100); return String.format(&quot;%s+%s 好了&quot;,s,s2); &#125;); SmallTool.printTimeAndThread(&quot;我在打王者&quot;); // join等待任务执行结束，返回任务结果 SmallTool.printTimeAndThread(String.format(&quot;%s,小白开吃&quot;,stringCompletableFuture.join())); &#125;&#125; 三个例子的基本模型 例子四我吃完了，准备结账，要求开发票，服务员收款后，要求另一个人开发票，开发票的同时，接到电话，拿到发票，回家养猪使用thenCompose也能执行 1234567891011121314151617public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;我吃完了&quot;); SmallTool.printTimeAndThread(&quot;结账，并且要求开发票&quot;); CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;服务员收款 500元&quot;); SmallTool.sleepMillis(100); return &quot;500&quot;; &#125;).thenApplyAsync(s -&gt; &#123; SmallTool.printTimeAndThread(String.format(&quot;服务员开发票中 面额 %s元&quot;, s)); SmallTool.sleepMillis(200); return String.format(&quot;%s元发票&quot;, s); &#125;); SmallTool.printTimeAndThread(&quot;我接到电话&quot;); SmallTool.printTimeAndThread(String.format(&quot;我拿到%s,准备回家&quot;,stringCompletableFuture.join()));&#125; 例子五我等车，等100路或200路公交都能到家，谁先来上谁 123456789101112131415public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;来到公交站&quot;); SmallTool.printTimeAndThread(&quot;等待100或200路公交&quot;); CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;等待100路公交车&quot;); SmallTool.sleepMillis(100); return &quot;100路来了&quot;; &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;等待200路公交&quot;); SmallTool.sleepMillis(200); return &quot;200路来了&quot;; &#125;),s -&gt; s); SmallTool.printTimeAndThread(String.format(&quot;%s,我上车了&quot;,stringCompletableFuture.join()));&#125; 例子六我坐在车上,司机撞树上了，只能打车回家了 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;来到公交站&quot;); SmallTool.printTimeAndThread(&quot;等待100或200路公交&quot;); CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;等待100路公交车&quot;); SmallTool.sleepMillis(100); return &quot;100路来了&quot;; &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;等待200路公交&quot;); SmallTool.sleepMillis(200); return &quot;200路来了&quot;; &#125;),s -&gt; &#123; SmallTool.printTimeAndThread(s); if (s.startsWith(&quot;100&quot;))&#123; throw new RuntimeException(&quot;撞树上了&quot;); &#125; return s; &#125;).exceptionally(throwable -&gt; &#123; SmallTool.printTimeAndThread(throwable.getMessage()); SmallTool.printTimeAndThread(&quot;打出租车回家&quot;); return &quot;出租车到了&quot;; &#125;); SmallTool.printTimeAndThread(String.format(&quot;%s,我上车了&quot;,stringCompletableFuture.join()));&#125; 例子七如果100路没来之前，就撞树上了，那么应该坐上200路公交","categories":[],"tags":[{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]},{"title":"常见多线程使用记录","slug":"note/多线程","date":"2020-05-26T14:55:20.000Z","updated":"2022-08-13T07:49:51.073Z","comments":true,"path":"2020/05/26/note/多线程/","link":"","permalink":"http://example.com/2020/05/26/note/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"起始一个高并发系统，最优秀的响应时间在200ms之内在调用两个service串行调用的情况下，响应已经到了400ms Callable想要获取一个有返回值的线程，使用Callable 无法通过new Thread的方式创建Callable 使用FutureTask 使用get方式获取响应时间-200ms 问题tomcat处理线程默认是200个，如果没有get到返回值，会导致阻塞解决方案，使用Servlet3.0异步请求 Servlet3.0异步直接返回Callable,return callable会回调Tomcat主线程接近0ms，子线程耗时300ms 原理 问题多线程调用多个接口，造成大量的并发解决方案使用批量接口，定时任务，或者CompletableFuture 定时任务加批量接口将请求装到队列中，每隔10ms批量调用，包装成list返回，通过分布式id，分发给对应的客户端 CountDownLatch模拟1w个并发 定时线程池 阻塞队列包装请求，放入唯一id，请求内容，CompletableFuture 封装数据 定时任务 如果队列为空，直接return 接口的参数包装 调用批量接口 测试单个调用的性能差距","categories":[],"tags":[{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]},{"title":"FastJson","slug":"note/FastJson","date":"2020-05-20T15:28:06.000Z","updated":"2022-08-13T07:20:12.409Z","comments":true,"path":"2020/05/20/note/FastJson/","link":"","permalink":"http://example.com/2020/05/20/note/FastJson/","excerpt":"","text":"什么是jsonjson是数据交换语言 Json数据格式两种数据格式，对象与数组(List集合和Map集合不同) TypeReference转换Map的过程中，不能设置泛型，没有泛型是不安全的，使用TypeReference，传入转后的Map集合结尾加上{},传入空的匿名内部类，因为TypeReference是protected修饰的构造方法，匿名内部类就是子类的内部对象 1Map&lt;String,Student&gt; map = JSON.parseObject(jsonString,new TypeReference&lt;Map&lt;String,Student&gt;&gt;()&#123;&#125;); SerializerFeature进行序列化时，定制自己的需求的枚举 设置空值为nullfastJson序列化的时候，空值是不会序列化的 1234567Student student = new Student(); student.setId(&quot;1&quot;); student.setName(&quot;张三&quot;); student.setAge(null); // 将student对象转换成Json字符串 String s = JSON.toJSONString(student, SerializerFeature.WriteMapNullValue); System.out.println(s); 输出 1&#123;&quot;age&quot;:null,&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;张三&quot;&#125; 设置空字段为双引1String s = JSON.toJSONString(student, SerializerFeature.WriteNullStringAsEmpty); 1&#123;&quot;age&quot;:&quot;&quot;,&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;张三&quot;&#125; 设置空布尔为false123student.setIsStudent(null);String s = JSON.toJSONString(student, SerializerFeature.WriteNullBooleanAsFalse); 1&#123;&quot;age&quot;:null,&quot;id&quot;:&quot;1&quot;,&quot;isStudent&quot;:false,&quot;name&quot;:&quot;张三&quot;&#125; 格式化日期12student.setBirthday(new Date());String s = JSON.toJSONString(student, SerializerFeature.WriteNullBooleanAsFalse); 1&#123;&quot;age&quot;:null,&quot;birthday&quot;:1653325416158,&quot;id&quot;:&quot;1&quot;,&quot;isStudent&quot;:false,&quot;name&quot;:&quot;张三&quot;&#125; 添加格式化 12String s = JSON.toJSONString(student, SerializerFeature.WriteNullBooleanAsFalse,SerializerFeature.WriteDateUseDateFormat);System.out.println(s); 1&#123;&quot;age&quot;:null,&quot;birthday&quot;:&quot;2022-05-24 01:06:39&quot;,&quot;id&quot;:&quot;1&quot;,&quot;isStudent&quot;:false,&quot;name&quot;:&quot;张三&quot;&#125; 格式化输出12String s = JSON.toJSONString(student, SerializerFeature.PrettyFormat,SerializerFeature.WriteDateUseDateFormat); System.out.println(s); 12345&#123; &quot;birthday&quot;:&quot;2022-05-24 01:13:18&quot;, &quot;id&quot;:&quot;1&quot;, &quot;name&quot;:&quot;张三&quot;&#125; JSONFieldname123 // name 指定序列化后的名字，@JSONField(name = &quot;studentName&quot;)private String name; 12345&#123; &quot;birthday&quot;:&quot;2022-05-24 01:16:59&quot;, &quot;id&quot;:&quot;1&quot;, &quot;studentName&quot;:&quot;张三&quot;&#125; ordinal123// 指定序列化后的顺序，值越小，越靠前@JSONField(ordinal = 2)private String age; format12@JSONField(format = &quot;YYYY-MM-dd&quot;)private Date birthday; 12345&#123; &quot;birthday&quot;:&quot;2022-22-24&quot;, &quot;id&quot;:&quot;1&quot;, &quot;name&quot;:&quot;张三&quot;&#125; serialize该字段是否被序列化，默认true 12@JSONField(serialize = false)private String name; 1234&#123; &quot;birthday&quot;:&quot;2022-05-24&quot;, &quot;id&quot;:&quot;1&quot;&#125; deserialize在参与反序列化的过程中，这个字段不参与成为对象的一部分 12@JSONField(deserialize = false)private String age;","categories":[],"tags":[{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]},{"title":"跨域请求","slug":"note/跨域请求","date":"2020-05-18T12:37:39.000Z","updated":"2022-08-13T07:50:12.444Z","comments":true,"path":"2020/05/18/note/跨域请求/","link":"","permalink":"http://example.com/2020/05/18/note/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/","excerpt":"","text":"什么是跨域请求 请求的目标URL和所在网页的URL的协议、域名、端口有一个不同，就算是跨域https,baidu,80 CORS跨域资源共享(Cross-origin resource sharing) 在跨域请求之前，先发送options请求询问服务器是否允许接下来的跨域请求OPTIONS请求中添加字段Origin:发起请求的域Access-Control-Request-Method：将要发起的跨域请求方式（GET/PUT/POST/DELETE）Access-Control-Request-Headers：将要发起的跨域请求中包含的请求头字段 服务器通过响应字段表示是否允许这个跨域请求，浏览器收到后检查如果不符合，就拒绝 Access-Control-Allow-Origin：允许哪些域来访问（*表示允许所有域的请求）Access-Control-Allow-Methods：允许哪些请求方式Access-Control-Allow-Headers：允许哪些请求头字段Access-Control-Allow-Credentials：是否允许携带Cookie 两个优化如果是一个简单请求，那么就直接发起请求，只需要加入Origin字段表明自己的来源，服务器根据Allow-Origin判断是否符合要求简单请求就是HEAD，GET，POST三者之一，请求头中的 四种常见的 POST 提交数据方式HTTP协议是由ASCII码传输的，建立在TCP/IP协议之上的应用层规范，规范把HTTP请求分为三个部分，状态行，请求头，消息主体协议规定POST提交的数据必须放到消息体中，但是没有规定编码方式。数据发送出去，服务端通过Content-Type字段对主体进行解析 application/x-www-form-urlencoded默认的编码方式，采用的浏览器的原生form表单，","categories":[],"tags":[{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]},{"title":"阿里巴巴开发规范.md","slug":"note/开发规范","date":"2020-05-13T03:13:39.000Z","updated":"2022-08-13T07:49:55.146Z","comments":true,"path":"2020/05/13/note/开发规范/","link":"","permalink":"http://example.com/2020/05/13/note/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","excerpt":"","text":"boolean不要以is开头，不然get方法就会出问题。 包名统一用单数形式。 使用完整的单词表达。 禁止出现魔法值，任何直接出现在代码中的字符串都是魔法值 使用long类型，必需使用大L,避免i1不分 equals容易出现空指针异常正确写法＂sbdl＂.equals=object推荐使用jdk7工具类equals(a，b) Integer使用static生成-128到127的之间所以的数字，所以128=128等于false所以所有的包装类都要用equals比较 任何货币金额，都以最小金额单位且整形来存储 浮点型数据，基本类型不能用==，包装类型不能用equals，1.0=1.00为false，因为精度不同，应该使用compareTo 禁止在bigDicmal中传入double，应该使用valueOf,实现原理是toString 所有的对象pojo都使用包装类型，不然有默认值所有的局部变量都使用基本类型 pojo类必须写toString方法，如果有继承，要super.toString 日期格式化，new SImpleDateFormat(“yyyy-MM-dd HH:mm:ss”)大写M 月份小写M 分钟24小时是大写H12小时是小写的h 获取当前毫秒数，System.currentTimeMillis()，底层使用的native方法精确计时使用Instant类，精确到纳秒 不要在程序中写死一年的天数，应该使用LocalDate.now().lengthOfYear()获取今年天数 只要重写了equals，就要重写hashCode方法,Set和Map的key依据hashCode判断,String重写的hashCode和equals方法，所以可以将String对象作为key来使用 判断集合是否为空，调用isEmpty1方法,因为不是遍历实现的size==0 使用stream流中的Collectors的toMap时，一定要使用含有参数类型BinaryOperator，参数值为mergeFunction的方法，否则出现相同的key，会抛出IllegalStateExceptionCollectors.toMap(key,value,(v1,v2)-&gt;v1)toMap时，value也不能为空，所以在转换之前要做filter过滤list.stream().filter(t-&gt;StringUtils.isNotBlank(t.getName)).collect(Collectors.toMap(t.getId,t.getName,(v1,v2)-&gt;v1)) ArrayList的subList不可用强转ArrayList,因为subList返回的内部类是SubList是ArrayList的视图，对于subList的操作都会返回到原ArrayList上 使用Map中的keySet/values/entrySet返回集合对象时，不可用对其添加元素操作，否则抛出UnsupportedOperationException 在subList场景中，对父类集合的增加和删除，均会导致子列表的遍历，增加，删除产生ConcurrentModificationException 集合转换数据的时候，list.toArray要指定参数，list.toArray(new String[0]),不然返回的object对象再转换，会出现转换异常，toArray的带参方法，length=0时，动态创建和size相同的数组 使用ArrayList.addAll底层实现还是toArray,所以使用之前要判断参数是否为空 不要在foreach中进行元素的add/remove操作。remove元素请使用Iterator，如果是并发操作请对Iterator对象加锁 获取单例对象要保证线程安全 创建线程或线程池，请指定有意义的线程名字，使用自定义线程工厂实现ThreadFactory， 线程资源必须通过线程池提供，通过ThreadPoolExecutor方法创建， SimpleDateFormat是线程不安全的类，不要定义为static变量,在jkd8应用中，使用Instant代替Date,LocalDateTime代替Calendar,使用DateTimeFormatter代替SimpleDateFormat 必须回收自定义的ThreadLocal变量，在线程池场景下，会造成内存泄漏，建议使用 123456aThreadLocal.set(userInfo) try&#123; &#125;finally()&#123; aThreadLocal.remove() &#125; 高并发中，能锁区块就不要锁整个方法，能用对象锁就不要用类锁 对多个资源，数据库表，对象同时加锁时，注意保持一致的加锁顺序，否则可能会造成死锁 使用阻塞等待获取锁的过程中，必须在try代码块之外，并且加锁方法与try之间没有任何可能抛出的异常，避免加锁成功后，在finally无法解锁 1234567new Lock(); lock.lock(); try&#123; &#125;finally&#123; lock.unlock() &#125; 在尝试机制获取锁中，进入业务代码块之前，必须先判断当前线程是否持有锁，锁的释放规则与锁的阻塞等待方法相同 123456789Lock lock=new aLock(); boolean isLocked=lock.tryLock(); if(isLocked)&#123; try&#123; doSomething(); &#125;finally&#123; lock.unlock(); &#125; &#125; 并发修改时，更新同一条记录，避免更新丢失，需要加锁，要么在应用层面加锁，要么在缓存加锁，要么在数据库使用乐观锁version,访问冲突概率小于20%，使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中一个没有捕获抛出异常，其他任务便会自动停止运行，使用ScheduledExecutorService则没有这个问题。 反 正 资金相关的信息，使用悲观锁，乐观锁在获取锁的同时完成了更新操作，检验逻辑容易出现漏洞，另外乐观锁对锁冲突的解决策略有较复杂的要求，处理不当容易造成系统压力，悲观锁原则：一锁，二判，三更新，四释放 在switch块中，每一个case都要通过continue/break/return来控制必须包含一个default放在语句最后，即使他什么代码也没有 在switch块之前判断param是否为null，不然default方法也不会执行，抛出空指针异常 三目运算符 1:2中，注意1:2的类型对齐时，可能会抛出空指针问题自动拆箱的触发场景1和2的值只要有一个是原始类型1和2的值类型不一致，会强制拆箱升级 高并发场景中，避免使用”等于”判断作为中断或退出条件，建议使用大于或小于比如：判断剩余商品数量等于0，终止发放商品，但是并发处理导致奖品数量瞬间变成了负数 Api规范协议:生产环境必须使用HTTPS路径:使用名词，推荐使用复数，请求方法已经表达了动作的含义,不能使用大写url，使用下环线分割，禁止携带表示请求内容的后缀，比如.json,.xml请求方法：Get:取出资源 POST:新建资源 PUT:更新资源 DELETE: 删除资源请求内容: url参数必须无敏感信息或加密,body里带的参数必须设置Content-Type响应体:响应体body可以防止多种数据类型，由Content-Type头来确定 前后端数据列表的接口返回，如果为空，返回空数组或空集合，避免前端很多琐碎的null判断 需要使用长整数一律用String，使用Long类型，js会自动转换成number类型(双浮点),会出现精度丢失,比如订单号，不要用long类型 http请求通过url传参，不能超过2048字节 http请求通过body传参，必须控制长度，nginx默认1mb，tomcat默认2mb 在分页场景中，输入的参数小于1则显示第一页，参数大于总页数则返回最后一页 正则表达式利用预编译功能，加快匹配速度，指不要在方法体内定义规则错误写法：Pattern pattern = Pattern.compile(“规则) 避免使用Apache Beanutils，可以使用Spring的BeanUtils(都是浅拷贝) 获取随机值，直接使用Random对象的nextInt和nextLong方法 可以通过预检查规避的RuntimeException不应该通过catch处理正例：if(a != null)反例：try{(a.getA)} catch(NullPointException e) 不要在finally块中使用return，try块中的return执行完成后，并不会马上返回，而是继续执行finally块，再返回 rpc调用，或者二方包调用时，捕获异常必须使用Throwable类进行拦截,在catch块中判断具体接受的异常 不可用直接使用日志系统(log4j,Logback)的api，而应该使用slf4j,JCL面门框架的Api,有利于各个类的日志统一处理 所有日志至少保存15天，对于当天日志，以应用名.log保存，保存在home/admin/应用名/logs/ 目录下,过往日志格式为:logName.log.保存日期 日期格式 yyyy-MM-dd 根据国家法律规定，网络运行状态，网络安全事件，个人敏感信息等操作日志，保存不少于六个月，并且网络多机备份 扩展日志命令方式appName_logType_logName.log 日志输出时，使用占位符拼接,内部实现的是StringBuilderlogger.debug(“id = {} and symbol = {}”,id,symbol); 对于trace/debug/info级别的日志输出,必须先判断开关 123if(logger.isDebugEnable())&#123; logger.debug(&quot;id = &#123;&#125;&quot;,id) &#125; 禁止使用System.out或System.err输出日志或者使用e.printStackTrace打印异常堆栈 打印日志，直接调用toString方法，不要通过JSONObject.toJsonString，不然会调用get方法 单元测试必须遵守AIR，自动化，独立性，可重复 单元测试之间不能先后调用,单元测试是可以重复执行的 用户个人页面必须权限校验 用户敏感数据，必须进行数据脱敏例如 显示 130****4320,防止泄漏 用户请求传入的任何参数必须做有效性验证page size 过大导致内存溢出恶意的order by 导致数据库慢查询缓存击穿SSRF，既伪造一个服务端请求，攻击者利用系统的某些接口，通过这个接口向目标系统发情攻击任意重定向SQL注入，Shell注入，反序列化注入正则输入源串拒接服务ReDoS 禁止向HTML页面输出未经安全过滤或者正确转义的用户数据 表单，AJAX必须执行CSRF安全验证跨站请求伪造是一类常见的编程漏洞，对于存在csrf的网站，攻击者可以实现通过构造好的url，只有受害者用户一访问，后台便可以在用户不知情的情况下修改用户数据可以理解为攻击者盗用了你的身份，然后以你的名义发起恶意请求，这个请求对于服务器来说完全合法 url外部重定向传入的地址，必须执行白名单过滤 表示是或者否，必须使用is_xxx命名，类型是unsigned tinyint 任何字段如果为非负数，必须是unsigned 表名，字段名都必须使用小写，数据库修改字段的代价很大，MySQL在Windows下是不区分大小写的，但是在Linux下区分大小写，所有不允许有大小写 表明使用用复数形式 主键索引名为pk_字段名，唯一索引为uk_字段名,普通索引为idx_字段名 小数类型一律用decimal,禁止使用float和double如果您要遵守公认会计原则(GAAP)规则，则货币栏必须至少包含4位小数，以确保舍入值不超过$0.01。 在这种情况下，应该定义具有4位小数的列，如下所示：amount DECIMAL(19,4),第一个参数是最大位数，第二个参数是小数位数如果存储范围超过decimal的范围，建议将数据拆成证书和小数分开存储 如果存储的字符串长度几乎相等，使用char定长字符串类型 varchar是可变长字符串，不预先分配内存空间，长度不要超过5000，如果长度大于这个值，使用text类型，单独出来一张表，用主键来对应，避免影响其他字段的索引值 表必备三字段，id，create_time,update_timeid为主键，类型为bigint unsigned，单表时自增，步长为1，create_time,update_time类型均为datetime类型, 业务上具有唯一特性的字段，即使是组合字段，也必须建立唯一索引唯一索引不会影响insert速度，但是提高查找速度是明显的，另外，即时在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必有脏数据产生 超过三个表禁止join，需要join的字段，数据类型必须保持一致，多表关联查询时,被关联的字段要有索引即时双表join,也要注意表索引 在varchar字段建立索引时，必须指定索引长度，没必要全字段建立索引，根据实际的文本区分度决定索引长度 页面搜索，严禁左模糊和全模糊，如果需要请走搜索引擎，索引文件根据最左匹配原则，如果左边的值未确定，那么无法使用此索引 count(*)会统计为列值为null的行,count(列名)不会 count(distinct 字段)计算该列除null之外的不重复行 null和任何值比较都是null，而不是true或false 如果某一列的值全为空，使用IFNULL(count(列名))或者IFNULL(SUM(列名)),避免空指针使用ISNULL判断是否为NULL，ISNULL(列名) 若分页查询，count为0,应该直接返回，避免执行后面的分页语句 不得使用外键和级联 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性 数据订正，要先select，避免出现误删除 对于数据库中多个表的查询，都需要在列名前加表的别名 在表查询中，一律不使用* 不要使用resultCLass当返回参数，即使所有的属性名与数据库字段对应，也需要定义resultMap，方便配置映射关系，使字段与DO类解耦 不允许直接拿HashMap和HashTable作为查询结果输出某同学为了避免写一个resultMap,直接使用HashMap接受数据库返回结果，结果出现本地把bigint转换成long值，而由于线上数据库版本不一样，解析成BigInteger，出现问题","categories":[],"tags":[{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]}],"categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"暂存文件","slug":"暂存文件","permalink":"http://example.com/tags/%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"config","slug":"config","permalink":"http://example.com/tags/config/"},{"name":"task","slug":"task","permalink":"http://example.com/tags/task/"},{"name":"插件","slug":"插件","permalink":"http://example.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"},{"name":"IDEA插件","slug":"IDEA插件","permalink":"http://example.com/tags/IDEA%E6%8F%92%E4%BB%B6/"}]}