{"meta":{"title":"谢谢你，因为有你，温暖了四季","subtitle":"qaqaq","description":"哥，别说了，我都流汗了","author":"QY","url":"http://example.com","root":"/"},"pages":[{"title":"分類","date":"2018-01-04T16:00:00.000Z","updated":"2022-05-30T03:05:17.170Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"標籤","date":"2018-01-04T16:00:00.000Z","updated":"2022-05-30T03:05:17.171Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"maven","slug":"开发记录/maven","date":"2022-06-10T02:34:00.000Z","updated":"2022-06-10T08:46:18.205Z","comments":true,"path":"2022/06/10/开发记录/maven/","link":"","permalink":"http://example.com/2022/06/10/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/maven/","excerpt":"","text":"命令行跳过测试打包1mvn clean install -Dmaven.test.skip=true","categories":[],"tags":[{"name":"开发记录","slug":"开发记录","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}]},{"title":"start.spring.io 镜像","slug":"工具/start.spring.io镜像","date":"2022-05-30T07:44:12.000Z","updated":"2022-05-30T07:44:39.692Z","comments":true,"path":"2022/05/30/工具/start.spring.io镜像/","link":"","permalink":"http://example.com/2022/05/30/%E5%B7%A5%E5%85%B7/start.spring.io%E9%95%9C%E5%83%8F/","excerpt":"","text":"使用阿里云https://start.aliyun.com","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"foreach批量插入","slug":"组件/foreach批量插入","date":"2022-05-30T07:30:29.000Z","updated":"2022-05-30T07:30:35.020Z","comments":true,"path":"2022/05/30/组件/foreach批量插入/","link":"","permalink":"http://example.com/2022/05/30/%E7%BB%84%E4%BB%B6/foreach%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/","excerpt":"","text":"12345678910111213141516@Testpublic void testInsertBatch() throws Exception &#123; long start = System.currentTimeMillis(); List&lt;User&gt; list = new ArrayList&lt;&gt;(); User user; for (int i = 0; i &lt; 10000; i++) &#123; user = new User(); user.setId(&quot;test&quot; + i); user.setName(&quot;name&quot; + i); user.setDelFlag(&quot;0&quot;); list.add(user); &#125; userService.insertBatch(list); long end = System.currentTimeMillis(); System.out.println(&quot;---------------&quot; + (start - end) + &quot;---------------&quot;);&#125; 12345678&lt;insert id=&quot;insertBatch&quot;&gt; INSERT INTO t_user (id, name, del_flag) VALUES &lt;foreach collection =&quot;list&quot; item=&quot;user&quot; separator =&quot;,&quot;&gt; (#&#123;user.id&#125;, #&#123;user.name&#125;, #&#123;user.delFlag&#125;) &lt;/foreach &gt;&lt;/insert&gt;","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"redis之list来实现限流","slug":"组件/redis之list来实现限流","date":"2022-05-30T03:50:07.000Z","updated":"2022-05-30T03:51:40.955Z","comments":true,"path":"2022/05/30/组件/redis之list来实现限流/","link":"","permalink":"http://example.com/2022/05/30/%E7%BB%84%E4%BB%B6/redis%E4%B9%8Blist%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81/","excerpt":"","text":"1234567891011121314String key = &quot;userId&quot; + &quot;接口名&quot; ; int listLength = llen(key); if (listLength &lt; 10) &#123; lpush(key, new ()); &#125; else &#123; long time = lindex(key, -1); if (now() - time &lt; 60) &#123; System.out.println(&quot;访问频率超过了限制，请稍后再试&quot;); &#125; else &#123; lpush(key, now); ltrim(key, 0, 9); &#125; &#125;","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"StringJoiner类","slug":"组件/StringJoiner类","date":"2020-05-26T17:02:04.000Z","updated":"2022-06-10T10:11:19.728Z","comments":true,"path":"2020/05/27/组件/StringJoiner类/","link":"","permalink":"http://example.com/2020/05/27/%E7%BB%84%E4%BB%B6/StringJoiner%E7%B1%BB/","excerpt":"","text":"引言：在阅读项目代码是，突然看到了 StringJoiner 这个类的使用，感觉很有意思，对实际开发中也有用，实际上是运用了 StringBuilder 的一个拼接字符串的封装处理。 介绍StringJoiner 是 Java8 新出的一个类，用于构造由分隔符分隔的字符序列，并可选择性地从提供的前缀开始和以提供的后缀结尾。省的我们开发人员再次通过 StringBuffer 或者 StingBuilder 拼接。我们查看一下一下代码，试着猜一下。 123StringJoiner sj = new StringJoiner(&quot;:&quot;, &quot;[&quot;, &quot;]&quot;);sj.add(&quot;George&quot;).add(&quot;Sally&quot;).add(&quot;Fred&quot;);String desiredString = sj.toString(); 代码输出为[George:Sally:Fred] 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package java.util;public final class StringJoiner &#123; private final String prefix;//前缀 private final String delimiter;//间隔符 private final String suffix;//后缀 private StringBuilder value;//值 private String emptyValue;//空值 public StringJoiner(CharSequence delimiter) &#123; this(delimiter, &quot;&quot;, &quot;&quot;);//默认前缀和后缀为&quot;&quot;,重载调用 &#125; public StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix) &#123; //间隔符，前缀和后缀判断是否为null，null将抛出异常 Objects.requireNonNull(prefix, &quot;The prefix must not be null&quot;); Objects.requireNonNull(delimiter, &quot;The delimiter must not be null&quot;); Objects.requireNonNull(suffix, &quot;The suffix must not be null&quot;); // 成员变量赋值 this.prefix = prefix.toString(); this.delimiter = delimiter.toString(); this.suffix = suffix.toString(); this.emptyValue = this.prefix + this.suffix;//空值被设置为只有前后缀 &#125; //设置空值，检查是否为null public StringJoiner setEmptyValue(CharSequence emptyValue) &#123; this.emptyValue = Objects.requireNonNull(emptyValue, &quot;The empty value must not be null&quot;).toString(); return this; &#125; @Override public String toString() &#123; if (value == null) &#123; return emptyValue;//没有值将返回空值或者后续设置的空值 &#125; else &#123; if (suffix.equals(&quot;&quot;)) &#123; return value.toString();//后缀为&quot;&quot;直接返回字符串，不用添加 &#125; else &#123; //后缀不为&quot;&quot;，添加后缀，然后直接返回字符串，修改长度 int initialLength = value.length(); String result = value.append(suffix).toString(); // reset value to pre-append initialLength value.setLength(initialLength); return result; &#125; &#125; &#125; 初始化，先添加前缀，有了之后每次先添加间隔符，StringBuilder后续append字符串 public StringJoiner add(CharSequence newElement) &#123; prepareBuilder().append(newElement); return this; &#125; //合并StringJoiner，注意后面StringJoiner 的前缀就不要了，后面的appen进来 public StringJoiner merge(StringJoiner other) &#123; Objects.requireNonNull(other); if (other.value != null) &#123; final int length = other.value.length(); // lock the length so that we can seize the data to be appended // before initiate copying to avoid interference, especially when // merge &#x27;this&#x27; StringBuilder builder = prepareBuilder(); builder.append(other.value, other.prefix.length(), length); &#125; return this; &#125; //初始化，先添加前缀，有了之后每次先添加间隔符 private StringBuilder prepareBuilder() &#123; if (value != null) &#123; value.append(delimiter); &#125; else &#123; value = new StringBuilder().append(prefix); &#125; return value; &#125; public int length() &#123; // Remember that we never actually append the suffix unless we return // the full (present) value or some sub-string or length of it, so that // we can add on more if we need to. //不忘添加后缀的长度 return (value != null ? value.length() + suffix.length() : emptyValue.length()); &#125;&#125;","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"CompletableFuture常用记录","slug":"组件/CompletableFuture","date":"2020-05-26T16:52:44.000Z","updated":"2022-06-10T10:11:19.728Z","comments":true,"path":"2020/05/27/组件/CompletableFuture/","link":"","permalink":"http://example.com/2020/05/27/%E7%BB%84%E4%BB%B6/CompletableFuture/","excerpt":"","text":"工具类123456789101112131415161718192021public class SmallTool &#123; public static void sleepMillis(Integer millis)&#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void printTimeAndThread(String tag)&#123; String result = new StringJoiner(&quot;\\t|\\t&quot;) .add(String.valueOf(System.currentTimeMillis())) .add(String.valueOf(Thread.currentThread().getId())) .add(Thread.currentThread().getName()) .add(tag) .toString(); System.out.println(result); &#125;&#125; 例子一1234567891011121314151617public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;我进了饭堂&quot;); SmallTool.printTimeAndThread(&quot;我点了滑鸡饭&quot;); // supplyAsync是java的函数式编程接口，叫提供者者， // 没有入参，只有一个返回值,因为我们返回了字符串，所以CompletableFuture的泛型是String CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;厨师炒菜&quot;); SmallTool.sleepMillis(200); SmallTool.printTimeAndThread(&quot;厨师打饭&quot;); SmallTool.sleepMillis(100); return &quot;滑鸡 + 饭 好了&quot;; &#125;); SmallTool.printTimeAndThread(&quot;我在打王者&quot;); // join等待任务执行结束，返回任务结果 SmallTool.printTimeAndThread(String.format(&quot;%s,小白开吃&quot;,stringCompletableFuture.join()));&#125; 输出结果 例子二一般来说，打饭这件事情是服务员干的 123456789101112131415161718192021public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;我进了饭堂&quot;); SmallTool.printTimeAndThread(&quot;我点了滑鸡饭&quot;); // supplyAsync是java的函数式编程接口，叫提供者者， // 没有入参，只有一个返回值,因为我们返回了字符串，所以CompletableFuture的泛型是String CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;厨师炒菜&quot;); SmallTool.sleepMillis(200); return &quot;滑鸡&quot;; // thenCompose要求我们传入一个Function接口，传入参数T，经过转换后返回R // 将前面任务的结果返回给下一个任务 &#125;).thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;服务员打饭&quot;); SmallTool.sleepMillis(100); return s+&quot;米饭&quot;; &#125;)); SmallTool.printTimeAndThread(&quot;我在打王者&quot;); // join等待任务执行结束，返回任务结果 SmallTool.printTimeAndThread(String.format(&quot;%s,小白开吃&quot;,stringCompletableFuture.join()));&#125; 例子三服务员还没做饭，要求厨师炒菜的时候，服务员同时蒸饭,要求炒菜和蒸饭同时返回，才能执行炒菜 1234567891011121314151617181920212223 public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;我进了饭堂&quot;); SmallTool.printTimeAndThread(&quot;我点了滑鸡饭&quot;); // supplyAsync是java的函数式编程接口，叫提供者者， // 没有入参，只有一个返回值,因为我们返回了字符串，所以CompletableFuture的泛型是String CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;厨师炒菜&quot;); SmallTool.sleepMillis(200); return &quot;滑鸡&quot;; &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;服务员蒸饭&quot;); SmallTool.sleepMillis(300); return &quot;米饭&quot;; &#125;),(s, s2) -&gt; &#123; SmallTool.printTimeAndThread(&quot;服务员打饭&quot;); SmallTool.sleepMillis(100); return String.format(&quot;%s+%s 好了&quot;,s,s2); &#125;); SmallTool.printTimeAndThread(&quot;我在打王者&quot;); // join等待任务执行结束，返回任务结果 SmallTool.printTimeAndThread(String.format(&quot;%s,小白开吃&quot;,stringCompletableFuture.join())); &#125;&#125; 三个例子的基本模型 例子四我吃完了，准备结账，要求开发票，服务员收款后，要求另一个人开发票，开发票的同时，接到电话，拿到发票，回家养猪使用thenCompose也能执行 1234567891011121314151617public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;我吃完了&quot;); SmallTool.printTimeAndThread(&quot;结账，并且要求开发票&quot;); CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;服务员收款 500元&quot;); SmallTool.sleepMillis(100); return &quot;500&quot;; &#125;).thenApplyAsync(s -&gt; &#123; SmallTool.printTimeAndThread(String.format(&quot;服务员开发票中 面额 %s元&quot;, s)); SmallTool.sleepMillis(200); return String.format(&quot;%s元发票&quot;, s); &#125;); SmallTool.printTimeAndThread(&quot;我接到电话&quot;); SmallTool.printTimeAndThread(String.format(&quot;我拿到%s,准备回家&quot;,stringCompletableFuture.join()));&#125; 例子五我等车，等100路或200路公交都能到家，谁先来上谁 123456789101112131415public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;来到公交站&quot;); SmallTool.printTimeAndThread(&quot;等待100或200路公交&quot;); CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;等待100路公交车&quot;); SmallTool.sleepMillis(100); return &quot;100路来了&quot;; &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;等待200路公交&quot;); SmallTool.sleepMillis(200); return &quot;200路来了&quot;; &#125;),s -&gt; s); SmallTool.printTimeAndThread(String.format(&quot;%s,我上车了&quot;,stringCompletableFuture.join()));&#125; 例子六我坐在车上,司机撞树上了，只能打车回家了 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; SmallTool.printTimeAndThread(&quot;来到公交站&quot;); SmallTool.printTimeAndThread(&quot;等待100或200路公交&quot;); CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;等待100路公交车&quot;); SmallTool.sleepMillis(100); return &quot;100路来了&quot;; &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123; SmallTool.printTimeAndThread(&quot;等待200路公交&quot;); SmallTool.sleepMillis(200); return &quot;200路来了&quot;; &#125;),s -&gt; &#123; SmallTool.printTimeAndThread(s); if (s.startsWith(&quot;100&quot;))&#123; throw new RuntimeException(&quot;撞树上了&quot;); &#125; return s; &#125;).exceptionally(throwable -&gt; &#123; SmallTool.printTimeAndThread(throwable.getMessage()); SmallTool.printTimeAndThread(&quot;打出租车回家&quot;); return &quot;出租车到了&quot;; &#125;); SmallTool.printTimeAndThread(String.format(&quot;%s,我上车了&quot;,stringCompletableFuture.join()));&#125; 例子七如果100路没来之前，就撞树上了，那么应该坐上200路公交","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"常见多线程使用记录","slug":"组件/多线程","date":"2020-05-26T14:55:20.000Z","updated":"2022-06-10T10:11:19.729Z","comments":true,"path":"2020/05/26/组件/多线程/","link":"","permalink":"http://example.com/2020/05/26/%E7%BB%84%E4%BB%B6/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"起始一个高并发系统，最优秀的响应时间在200ms之内在调用两个service串行调用的情况下，响应已经到了400ms Callable想要获取一个有返回值的线程，使用Callable 无法通过new Thread的方式创建Callable 使用FutureTask 使用get方式获取响应时间-200ms 问题tomcat处理线程默认是200个，如果没有get到返回值，会导致阻塞解决方案，使用Servlet3.0异步请求 Servlet3.0异步直接返回Callable,return callable会回调Tomcat主线程接近0ms，子线程耗时300ms 原理 问题多线程调用多个接口，造成大量的并发解决方案使用批量接口，定时任务，或者CompletableFuture 定时任务加批量接口将请求装到队列中，每隔10ms批量调用，包装成list返回，通过分布式id，分发给对应的客户端 CountDownLatch模拟1w个并发 定时线程池 阻塞队列包装请求，放入唯一id，请求内容，CompletableFuture 封装数据 定时任务 如果队列为空，直接return 接口的参数包装 调用批量接口 测试单个调用的性能差距","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"EasyExcel","slug":"组件/EasyExcel","date":"2020-05-24T16:50:54.000Z","updated":"2022-06-10T10:11:19.728Z","comments":true,"path":"2020/05/25/组件/EasyExcel/","link":"","permalink":"http://example.com/2020/05/25/%E7%BB%84%E4%BB%B6/EasyExcel/","excerpt":"","text":"Apache POI 有SAX模式和Dom模式解析，Dom是一次性读取，容易造成内存溢出SAX模式相对比较复杂，在Excel03和07版本，数据存储的方式截然不同，sax解析方式也不同一个3M的Excel依然需要100M的内存 userModel模式 大部分使用POI都是使用userModel模式，随便拷贝个代码就能用，但是转换要几百行代码，而且十分消耗内存，在并发情况下，会造成OOM和频繁的full gc EasyExcel的改进重写了POI对07版本的Excel解析 把内存消耗从100m降到了10m左右，并且再大的Excel也不会出现内存溢出，但是03版依然依赖于SAX模式","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"Apollo配置中心","slug":"组件/Apollo配置中心","date":"2020-05-24T15:35:54.000Z","updated":"2022-06-10T10:11:19.727Z","comments":true,"path":"2020/05/24/组件/Apollo配置中心/","link":"","permalink":"http://example.com/2020/05/24/%E7%BB%84%E4%BB%B6/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/","excerpt":"","text":"主流配置中心产品 Disconf2014年7月百度开源的配置管理中心，专注于各种「分布式系统配置管理」的「通用组件」和「通用平台」, 提供统一的「配置管理服务」。目前已经不再维护更新。https://github.com/knightliao/disconf Spring Cloud Config2014年9月开源，Spring Cloud 生态组件，可以和Spring Cloud体系无缝整合。https://github.com/spring-cloud/spring-cloud-config Apollo2016年5月，携程开源的配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。https://github.com/ctripcorp/apollo Nacos2018年6月，阿里开源的配置中心，也可以做DNS和RPC的服务发现。https://github.com/alibaba/nacos产品对比Apollo集成了数据库+Eureka+版本控制+权限管理+Http Long Polling … … 总的来说，Apollo和Nacos相对于Spring Cloud Config的生态支持更广，在配置管理流程上做的更好，其成熟度和企业级特性要强于Spring Cloud Config。Apollo相对于Nacos在配置管理做的更加全面，Nacos则使用起来相对比较简洁，在对性能要求比较高的大规模场景更适合。但对于一个开源项目的选型，项目上的人力投入（迭代进度、文档的完整性）、社区的活跃度（issue的数量和解决速度、Contributor数量、社群的交流频次等），这些因素也比较关键。Apollo目前在国内开发者社区比较热，在Github上有超过1w5颗星，在国内众多互联网公司有落地案例，可以说Apollo是目前配置中心产品领域Number1的产品，所以从目前来看Apollo是最合适的配置中心选型。","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"1-环境搭建","slug":"万融/1-环境搭建","date":"2020-05-24T14:41:45.000Z","updated":"2022-06-10T10:11:19.727Z","comments":true,"path":"2020/05/24/万融/1-环境搭建/","link":"","permalink":"http://example.com/2020/05/24/%E4%B8%87%E8%9E%8D/1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"","categories":[],"tags":[{"name":"万融","slug":"万融","permalink":"http://example.com/tags/%E4%B8%87%E8%9E%8D/"}]},{"title":"微信支付","slug":"组件/微信支付","date":"2020-05-22T13:51:42.000Z","updated":"2022-06-10T10:11:19.729Z","comments":true,"path":"2020/05/22/组件/微信支付/","link":"","permalink":"http://example.com/2020/05/22/%E7%BB%84%E4%BB%B6/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/","excerpt":"","text":"调用流程 1.调用url地址2.初始化HttpClient对象3.设置是否是https4.设置请求参数,一般为 Map&lt;String, String&gt;5.发起post请求6.获取结果 httpClient.getContent7.根据return_code返回结果 扫码支付http工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public class HttpClient &#123; private String url; private Map&lt;String, String&gt; param; private int statusCode; private String content; private String xmlParam; private boolean isHttps; public boolean isHttps() &#123; return isHttps; &#125; public void setHttps(boolean isHttps) &#123; this.isHttps = isHttps; &#125; public String getXmlParam() &#123; return xmlParam; &#125; public void setXmlParam(String xmlParam) &#123; this.xmlParam = xmlParam; &#125; public HttpClient(String url, Map&lt;String, String&gt; param) &#123; this.url = url; this.param = param; &#125; public HttpClient(String url) &#123; this.url = url; &#125; public void setParameter(Map&lt;String, String&gt; map) &#123; param = map; &#125; public void addParameter(String key, String value) &#123; if (param == null) param = new HashMap&lt;String, String&gt;(); param.put(key, value); &#125; public void post() throws ClientProtocolException, IOException &#123; HttpPost http = new HttpPost(url); setEntity(http); execute(http); &#125; public void put() throws ClientProtocolException, IOException &#123; HttpPut http = new HttpPut(url); setEntity(http); execute(http); &#125; public void get() throws ClientProtocolException, IOException &#123; if (param != null) &#123; StringBuilder url = new StringBuilder(this.url); boolean isFirst = true; for (String key : param.keySet()) &#123; if (isFirst) &#123; url.append(&quot;?&quot;); &#125;else &#123; url.append(&quot;&amp;&quot;); &#125; url.append(key).append(&quot;=&quot;).append(param.get(key)); &#125; this.url = url.toString(); &#125; HttpGet http = new HttpGet(url); execute(http); &#125; /** * set http post,put param */ private void setEntity(HttpEntityEnclosingRequestBase http) &#123; if (param != null) &#123; List&lt;NameValuePair&gt; nvps = new LinkedList&lt;NameValuePair&gt;(); for (String key : param.keySet()) &#123; nvps.add(new BasicNameValuePair(key, param.get(key))); // 参数 &#125; http.setEntity(new UrlEncodedFormEntity(nvps, Consts.UTF_8)); // 设置参数 &#125; if (xmlParam != null) &#123; http.setEntity(new StringEntity(xmlParam, Consts.UTF_8)); &#125; &#125; private void execute(HttpUriRequest http) throws ClientProtocolException, IOException &#123; CloseableHttpClient httpClient = null; try &#123; if (isHttps) &#123; SSLContext sslContext = new SSLContextBuilder() .loadTrustMaterial(null, new TrustStrategy() &#123; // 信任所有 @Override public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; return true; &#125; &#125;).build(); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory( sslContext); httpClient = HttpClients.custom().setSSLSocketFactory(sslsf) .build(); &#125; else &#123; httpClient = HttpClients.createDefault(); &#125; CloseableHttpResponse response = httpClient.execute(http); try &#123; if (response != null) &#123; if (response.getStatusLine() != null) &#123; statusCode = response.getStatusLine().getStatusCode(); &#125; HttpEntity entity = response.getEntity(); // 响应内容 content = EntityUtils.toString(entity, Consts.UTF_8); &#125; &#125; finally &#123; response.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; httpClient.close(); &#125; &#125; public int getStatusCode() &#123; return statusCode; &#125; public String getContent() throws ParseException, IOException &#123; return content; &#125;&#125; 生成二维码获取统一下单的url地址，生成二维码图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Overridepublic String getPayUrl(Map&lt;String, String&gt; map) &#123; // 统一下单接口链接 String url = &quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;; HttpClient httpClient = new HttpClient(url); httpClient.setHttps(true); Map&lt;String, String&gt; param = new HashMap&lt;&gt;(); // 公众账号ID param.put(&quot;appid&quot;,appId); // 商户号 param.put(&quot;mch_id&quot;,partner); // 随机字符串 param.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr()); // 商品描述 param.put(&quot;body&quot;,map.get(&quot;body&quot;)); // 商户订单号(自己项目的订单号） param.put(&quot;out_trade_no&quot;,map.get(&quot;orderId&quot;)); // 标价金额 param.put(&quot;total_fee&quot;,map.get(&quot;money&quot;)); // 终端IP param.put(&quot;spbill_create_ip&quot;,&quot;192.168.200.1&quot;); // 通知地址(异步接收微信支付结果) param.put(&quot;notify_url&quot;,notifyUrl); // 交易类型(扫码支付） param.put(&quot;trade_type&quot;,&quot;NATIVE&quot;); // 附加参数，在接收的时候原样返回 Map&lt;String,String&gt; attachMap = new HashMap&lt;&gt;(); attachMap.put(&quot;exchange&quot;,map.get(&quot;exchange&quot;)); attachMap.put(&quot;routingKey&quot;,map.get(&quot;routingKey&quot;)); param.put(&quot;attach&quot;, JSONObject.toJSONString(attachMap)); try &#123; // 将参数转换为xml格式，同时生成签名 String xmlParam = WXPayUtil.generateSignedXml(param, partnerkey); // 设置请求参数 httpClient.setXmlParam(xmlParam); // 发起post请求 httpClient.post(); // 获取结果 String content = httpClient.getContent(); // 解析xml格式的数据,转换成map数据 Map&lt;String, String&gt; result = WXPayUtil.xmlToMap(content); // 返回结果 if (result.get(&quot;return_code&quot;).equals(&quot;SUCCESS&quot;) &amp;&amp; result.get(&quot;result_code&quot;).equals(&quot;SUCCESS&quot;))&#123; return result.get(&quot;code_url&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"FastJson","slug":"组件/FastJson","date":"2020-05-20T15:28:06.000Z","updated":"2022-05-30T03:05:17.170Z","comments":true,"path":"2020/05/20/组件/FastJson/","link":"","permalink":"http://example.com/2020/05/20/%E7%BB%84%E4%BB%B6/FastJson/","excerpt":"","text":"什么是jsonjson是数据交换语言 Json数据格式两种数据格式，对象与数组(List集合和Map集合不同) TypeReference转换Map的过程中，不能设置泛型，没有泛型是不安全的，使用TypeReference，传入转后的Map集合结尾加上{},传入空的匿名内部类，因为TypeReference是protected修饰的构造方法，匿名内部类就是子类的内部对象 1Map&lt;String,Student&gt; map = JSON.parseObject(jsonString,new TypeReference&lt;Map&lt;String,Student&gt;&gt;()&#123;&#125;); SerializerFeature进行序列化时，定制自己的需求的枚举 设置空值为nullfastJson序列化的时候，空值是不会序列化的 1234567Student student = new Student(); student.setId(&quot;1&quot;); student.setName(&quot;张三&quot;); student.setAge(null); // 将student对象转换成Json字符串 String s = JSON.toJSONString(student, SerializerFeature.WriteMapNullValue); System.out.println(s); 输出 1&#123;&quot;age&quot;:null,&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;张三&quot;&#125; 设置空字段为双引1String s = JSON.toJSONString(student, SerializerFeature.WriteNullStringAsEmpty); 1&#123;&quot;age&quot;:&quot;&quot;,&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;张三&quot;&#125; 设置空布尔为false123student.setIsStudent(null);String s = JSON.toJSONString(student, SerializerFeature.WriteNullBooleanAsFalse); 1&#123;&quot;age&quot;:null,&quot;id&quot;:&quot;1&quot;,&quot;isStudent&quot;:false,&quot;name&quot;:&quot;张三&quot;&#125; 格式化日期12student.setBirthday(new Date());String s = JSON.toJSONString(student, SerializerFeature.WriteNullBooleanAsFalse); 1&#123;&quot;age&quot;:null,&quot;birthday&quot;:1653325416158,&quot;id&quot;:&quot;1&quot;,&quot;isStudent&quot;:false,&quot;name&quot;:&quot;张三&quot;&#125; 添加格式化 12String s = JSON.toJSONString(student, SerializerFeature.WriteNullBooleanAsFalse,SerializerFeature.WriteDateUseDateFormat);System.out.println(s); 1&#123;&quot;age&quot;:null,&quot;birthday&quot;:&quot;2022-05-24 01:06:39&quot;,&quot;id&quot;:&quot;1&quot;,&quot;isStudent&quot;:false,&quot;name&quot;:&quot;张三&quot;&#125; 格式化输出12String s = JSON.toJSONString(student, SerializerFeature.PrettyFormat,SerializerFeature.WriteDateUseDateFormat); System.out.println(s); 12345&#123; &quot;birthday&quot;:&quot;2022-05-24 01:13:18&quot;, &quot;id&quot;:&quot;1&quot;, &quot;name&quot;:&quot;张三&quot;&#125; JSONFieldname123 // name 指定序列化后的名字，@JSONField(name = &quot;studentName&quot;)private String name; 12345&#123; &quot;birthday&quot;:&quot;2022-05-24 01:16:59&quot;, &quot;id&quot;:&quot;1&quot;, &quot;studentName&quot;:&quot;张三&quot;&#125; ordinal123// 指定序列化后的顺序，值越小，越靠前@JSONField(ordinal = 2)private String age; format12@JSONField(format = &quot;YYYY-MM-dd&quot;)private Date birthday; 12345&#123; &quot;birthday&quot;:&quot;2022-22-24&quot;, &quot;id&quot;:&quot;1&quot;, &quot;name&quot;:&quot;张三&quot;&#125; serialize该字段是否被序列化，默认true 12@JSONField(serialize = false)private String name; 1234&#123; &quot;birthday&quot;:&quot;2022-05-24&quot;, &quot;id&quot;:&quot;1&quot;&#125; deserialize在参与反序列化的过程中，这个字段不参与成为对象的一部分 12@JSONField(deserialize = false)private String age;","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"跨域请求","slug":"开发规范/跨域请求","date":"2020-05-18T12:37:39.000Z","updated":"2022-05-30T03:05:17.169Z","comments":true,"path":"2020/05/18/开发规范/跨域请求/","link":"","permalink":"http://example.com/2020/05/18/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/","excerpt":"","text":"什么是跨域请求 请求的目标URL和所在网页的URL的协议、域名、端口有一个不同，就算是跨域https,baidu,80 CORS跨域资源共享(Cross-origin resource sharing) 在跨域请求之前，先发送options请求询问服务器是否允许接下来的跨域请求OPTIONS请求中添加字段Origin:发起请求的域Access-Control-Request-Method：将要发起的跨域请求方式（GET/PUT/POST/DELETE）Access-Control-Request-Headers：将要发起的跨域请求中包含的请求头字段 服务器通过响应字段表示是否允许这个跨域请求，浏览器收到后检查如果不符合，就拒绝 Access-Control-Allow-Origin：允许哪些域来访问（*表示允许所有域的请求）Access-Control-Allow-Methods：允许哪些请求方式Access-Control-Allow-Headers：允许哪些请求头字段Access-Control-Allow-Credentials：是否允许携带Cookie 两个优化如果是一个简单请求，那么就直接发起请求，只需要加入Origin字段表明自己的来源，服务器根据Allow-Origin判断是否符合要求简单请求就是HEAD，GET，POST三者之一，请求头中的 四种常见的 POST 提交数据方式HTTP协议是由ASCII码传输的，建立在TCP/IP协议之上的应用层规范，规范把HTTP请求分为三个部分，状态行，请求头，消息主体协议规定POST提交的数据必须放到消息体中，但是没有规定编码方式。数据发送出去，服务端通过Content-Type字段对主体进行解析 application/x-www-form-urlencoded默认的编码方式，采用的浏览器的原生form表单，","categories":[],"tags":[{"name":"开发记录","slug":"开发记录","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}]},{"title":"Java泛型(TODO)","slug":"开发规范/Java泛型","date":"2020-05-17T01:46:31.000Z","updated":"2022-05-30T03:05:17.168Z","comments":true,"path":"2020/05/17/开发规范/Java泛型/","link":"","permalink":"http://example.com/2020/05/17/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Java%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"什么是泛型 Java泛型（generics) 提供编译时类型检测的机制，允许我们在编译时检测非法的数据结构泛型的本质就是类型参数化 使用泛型指定存储类型为String指定了数据类型，减少了数据类型转换 ArrayList源码 泛型类 泛型标识–整型形参T 创建对象的时候指定具体的数据类型调用构造方法的时候，或者set的时候指定的 123public class Test&lt;T&gt; &#123; private T key;&#125; 123456789101112131415161718public class A &#123; public static void main(String[] args) &#123; Test&lt;String&gt; stringTest = new Test&lt;&gt;(&quot;a&quot;); String key = stringTest.getKey(); System.out.println(key); Test&lt;Integer&gt; integerTest = new Test&lt;&gt;(1); System.out.println(integerTest.getKey()); // 泛型类在创建对象的时候，没有指定类型，将按照Object类型来操作 Test test = new Test(2); // 不支持基本数据类型,因为int并不是继承自Object的 //Generic&lt;int&gt; generic = new Generic(); // 泛型类从逻辑上可以看成不同的类型，但是实际上是相同的类型 System.out.println(integerTest.getClass() == stringTest.getClass()); &#125; 抽奖例子123456789101112131415161718192021222324public class Product&lt;T&gt; &#123; private T product; Random random = new Random(); ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); /** * 添加奖品 * @param t */ public void addProduct(T t)&#123; list.add(t); &#125; /** * 抽奖 * @return */ public T getProduct()&#123; product = list.get(random.nextInt(list.size())); return product; &#125;&#125; 123456789101112131415161718192021public class A &#123; public static void main(String[] args) &#123; Product&lt;String&gt; stringProduct = new Product&lt;&gt;(); // 发奖品 String[] strings = &#123;&quot;苹果手机&quot;,&quot;华为手机&quot;,&quot;扫地机器人&quot;&#125;; for (int i = 0; i &lt; strings.length; i++) &#123; stringProduct.addProduct(strings[i]); &#125; String product1 = stringProduct.getProduct(); System.out.println(product1); // 发红包 Product&lt;Integer&gt; integerProduct = new Product&lt;&gt;(); int[] ints = &#123;10000,5000,3000,2000,1&#125;; Arrays.stream(ints).forEach(value -&gt; &#123; integerProduct.addProduct(value); &#125;); System.out.println(integerProduct.getProduct()); &#125;&#125;","categories":[],"tags":[{"name":"开发记录","slug":"开发记录","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}]},{"title":"阿里巴巴开发规范.md","slug":"开发规范/阿里巴巴开发规范","date":"2020-05-13T03:13:39.000Z","updated":"2022-05-30T03:05:17.169Z","comments":true,"path":"2020/05/13/开发规范/阿里巴巴开发规范/","link":"","permalink":"http://example.com/2020/05/13/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","excerpt":"","text":"boolean不要以is开头，不然get方法就会出问题。 包名统一用单数形式。 使用完整的单词表达。 禁止出现魔法值，任何直接出现在代码中的字符串都是魔法值 使用long类型，必需使用大L,避免i1不分 equals容易出现空指针异常正确写法＂sbdl＂.equals=object推荐使用jdk7工具类equals(a，b) Integer使用static生成-128到127的之间所以的数字，所以128=128等于false所以所有的包装类都要用equals比较 任何货币金额，都以最小金额单位且整形来存储 浮点型数据，基本类型不能用==，包装类型不能用equals，1.0=1.00为false，因为精度不同，应该使用compareTo 禁止在bigDicmal中传入double，应该使用valueOf,实现原理是toString 所有的对象pojo都使用包装类型，不然有默认值所有的局部变量都使用基本类型 pojo类必须写toString方法，如果有继承，要super.toString 日期格式化，new SImpleDateFormat(“yyyy-MM-dd HH:mm:ss”)大写M 月份小写M 分钟24小时是大写H12小时是小写的h 获取当前毫秒数，System.currentTimeMillis()，底层使用的native方法精确计时使用Instant类，精确到纳秒 不要在程序中写死一年的天数，应该使用LocalDate.now().lengthOfYear()获取今年天数 只要重写了equals，就要重写hashCode方法,Set和Map的key依据hashCode判断,String重写的hashCode和equals方法，所以可以将String对象作为key来使用 判断集合是否为空，调用isEmpty1方法,因为不是遍历实现的size==0 使用stream流中的Collectors的toMap时，一定要使用含有参数类型BinaryOperator，参数值为mergeFunction的方法，否则出现相同的key，会抛出IllegalStateExceptionCollectors.toMap(key,value,(v1,v2)-&gt;v1)toMap时，value也不能为空，所以在转换之前要做filter过滤list.stream().filter(t-&gt;StringUtils.isNotBlank(t.getName)).collect(Collectors.toMap(t.getId,t.getName,(v1,v2)-&gt;v1)) ArrayList的subList不可用强转ArrayList,因为subList返回的内部类是SubList是ArrayList的视图，对于subList的操作都会返回到原ArrayList上 使用Map中的keySet/values/entrySet返回集合对象时，不可用对其添加元素操作，否则抛出UnsupportedOperationException 在subList场景中，对父类集合的增加和删除，均会导致子列表的遍历，增加，删除产生ConcurrentModificationException 集合转换数据的时候，list.toArray要指定参数，list.toArray(new String[0]),不然返回的object对象再转换，会出现转换异常，toArray的带参方法，length=0时，动态创建和size相同的数组 使用ArrayList.addAll底层实现还是toArray,所以使用之前要判断参数是否为空 不要在foreach中进行元素的add/remove操作。remove元素请使用Iterator，如果是并发操作请对Iterator对象加锁 获取单例对象要保证线程安全 创建线程或线程池，请指定有意义的线程名字，使用自定义线程工厂实现ThreadFactory， 线程资源必须通过线程池提供，通过ThreadPoolExecutor方法创建， SimpleDateFormat是线程不安全的类，不要定义为static变量,在jkd8应用中，使用Instant代替Date,LocalDateTime代替Calendar,使用DateTimeFormatter代替SimpleDateFormat 必须回收自定义的ThreadLocal变量，在线程池场景下，会造成内存泄漏，建议使用 123456aThreadLocal.set(userInfo) try&#123; &#125;finally()&#123; aThreadLocal.remove() &#125; 高并发中，能锁区块就不要锁整个方法，能用对象锁就不要用类锁 对多个资源，数据库表，对象同时加锁时，注意保持一致的加锁顺序，否则可能会造成死锁 使用阻塞等待获取锁的过程中，必须在try代码块之外，并且加锁方法与try之间没有任何可能抛出的异常，避免加锁成功后，在finally无法解锁 1234567new Lock(); lock.lock(); try&#123; &#125;finally&#123; lock.unlock() &#125; 在尝试机制获取锁中，进入业务代码块之前，必须先判断当前线程是否持有锁，锁的释放规则与锁的阻塞等待方法相同 123456789Lock lock=new aLock(); boolean isLocked=lock.tryLock(); if(isLocked)&#123; try&#123; doSomething(); &#125;finally&#123; lock.unlock(); &#125; &#125; 并发修改时，更新同一条记录，避免更新丢失，需要加锁，要么在应用层面加锁，要么在缓存加锁，要么在数据库使用乐观锁version,访问冲突概率小于20%，使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中一个没有捕获抛出异常，其他任务便会自动停止运行，使用ScheduledExecutorService则没有这个问题。 反 正 资金相关的信息，使用悲观锁，乐观锁在获取锁的同时完成了更新操作，检验逻辑容易出现漏洞，另外乐观锁对锁冲突的解决策略有较复杂的要求，处理不当容易造成系统压力，悲观锁原则：一锁，二判，三更新，四释放 在switch块中，每一个case都要通过continue/break/return来控制必须包含一个default放在语句最后，即使他什么代码也没有 在switch块之前判断param是否为null，不然default方法也不会执行，抛出空指针异常 三目运算符 1:2中，注意1:2的类型对齐时，可能会抛出空指针问题自动拆箱的触发场景1和2的值只要有一个是原始类型1和2的值类型不一致，会强制拆箱升级 高并发场景中，避免使用”等于”判断作为中断或退出条件，建议使用大于或小于比如：判断剩余商品数量等于0，终止发放商品，但是并发处理导致奖品数量瞬间变成了负数 Api规范协议:生产环境必须使用HTTPS路径:使用名词，推荐使用复数，请求方法已经表达了动作的含义,不能使用大写url，使用下环线分割，禁止携带表示请求内容的后缀，比如.json,.xml请求方法：Get:取出资源 POST:新建资源 PUT:更新资源 DELETE: 删除资源请求内容: url参数必须无敏感信息或加密,body里带的参数必须设置Content-Type响应体:响应体body可以防止多种数据类型，由Content-Type头来确定 前后端数据列表的接口返回，如果为空，返回空数组或空集合，避免前端很多琐碎的null判断 需要使用长整数一律用String，使用Long类型，js会自动转换成number类型(双浮点),会出现精度丢失,比如订单号，不要用long类型 http请求通过url传参，不能超过2048字节 http请求通过body传参，必须控制长度，nginx默认1mb，tomcat默认2mb 在分页场景中，输入的参数小于1则显示第一页，参数大于总页数则返回最后一页 正则表达式利用预编译功能，加快匹配速度，指不要在方法体内定义规则错误写法：Pattern pattern = Pattern.compile(“规则) 避免使用Apache Beanutils，可以使用Spring的BeanUtils(都是浅拷贝) 获取随机值，直接使用Random对象的nextInt和nextLong方法 可以通过预检查规避的RuntimeException不应该通过catch处理正例：if(a != null)反例：try{(a.getA)} catch(NullPointException e) 不要在finally块中使用return，try块中的return执行完成后，并不会马上返回，而是继续执行finally块，再返回 rpc调用，或者二方包调用时，捕获异常必须使用Throwable类进行拦截,在catch块中判断具体接受的异常 不可用直接使用日志系统(log4j,Logback)的api，而应该使用slf4j,JCL面门框架的Api,有利于各个类的日志统一处理 所有日志至少保存15天，对于当天日志，以应用名.log保存，保存在home/admin/应用名/logs/ 目录下,过往日志格式为:logName.log.保存日期 日期格式 yyyy-MM-dd 根据国家法律规定，网络运行状态，网络安全事件，个人敏感信息等操作日志，保存不少于六个月，并且网络多机备份 扩展日志命令方式appName_logType_logName.log 日志输出时，使用占位符拼接,内部实现的是StringBuilderlogger.debug(“id = {} and symbol = {}”,id,symbol); 对于trace/debug/info级别的日志输出,必须先判断开关 123if(logger.isDebugEnable())&#123; logger.debug(&quot;id = &#123;&#125;&quot;,id) &#125; 禁止使用System.out或System.err输出日志或者使用e.printStackTrace打印异常堆栈 打印日志，直接调用toString方法，不要通过JSONObject.toJsonString，不然会调用get方法 单元测试必须遵守AIR，自动化，独立性，可重复 单元测试之间不能先后调用,单元测试是可以重复执行的 用户个人页面必须权限校验 用户敏感数据，必须进行数据脱敏例如 显示 130****4320,防止泄漏 用户请求传入的任何参数必须做有效性验证page size 过大导致内存溢出恶意的order by 导致数据库慢查询缓存击穿SSRF，既伪造一个服务端请求，攻击者利用系统的某些接口，通过这个接口向目标系统发情攻击任意重定向SQL注入，Shell注入，反序列化注入正则输入源串拒接服务ReDoS 禁止向HTML页面输出未经安全过滤或者正确转义的用户数据 表单，AJAX必须执行CSRF安全验证跨站请求伪造是一类常见的编程漏洞，对于存在csrf的网站，攻击者可以实现通过构造好的url，只有受害者用户一访问，后台便可以在用户不知情的情况下修改用户数据可以理解为攻击者盗用了你的身份，然后以你的名义发起恶意请求，这个请求对于服务器来说完全合法 url外部重定向传入的地址，必须执行白名单过滤 表示是或者否，必须使用is_xxx命名，类型是unsigned tinyint 任何字段如果为非负数，必须是unsigned 表名，字段名都必须使用小写，数据库修改字段的代价很大，MySQL在Windows下是不区分大小写的，但是在Linux下区分大小写，所有不允许有大小写 表明使用用复数形式 主键索引名为pk_字段名，唯一索引为uk_字段名,普通索引为idx_字段名 小数类型一律用decimal,禁止使用float和double如果您要遵守公认会计原则(GAAP)规则，则货币栏必须至少包含4位小数，以确保舍入值不超过$0.01。 在这种情况下，应该定义具有4位小数的列，如下所示：amount DECIMAL(19,4),第一个参数是最大位数，第二个参数是小数位数如果存储范围超过decimal的范围，建议将数据拆成证书和小数分开存储 如果存储的字符串长度几乎相等，使用char定长字符串类型 varchar是可变长字符串，不预先分配内存空间，长度不要超过5000，如果长度大于这个值，使用text类型，单独出来一张表，用主键来对应，避免影响其他字段的索引值 表必备三字段，id，create_time,update_timeid为主键，类型为bigint unsigned，单表时自增，步长为1，create_time,update_time类型均为datetime类型, 业务上具有唯一特性的字段，即使是组合字段，也必须建立唯一索引唯一索引不会影响insert速度，但是提高查找速度是明显的，另外，即时在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必有脏数据产生 超过三个表禁止join，需要join的字段，数据类型必须保持一致，多表关联查询时,被关联的字段要有索引即时双表join,也要注意表索引 在varchar字段建立索引时，必须指定索引长度，没必要全字段建立索引，根据实际的文本区分度决定索引长度 页面搜索，严禁左模糊和全模糊，如果需要请走搜索引擎，索引文件根据最左匹配原则，如果左边的值未确定，那么无法使用此索引 count(*)会统计为列值为null的行,count(列名)不会 count(distinct 字段)计算该列除null之外的不重复行 null和任何值比较都是null，而不是true或false 如果某一列的值全为空，使用IFNULL(count(列名))或者IFNULL(SUM(列名)),避免空指针使用ISNULL判断是否为NULL，ISNULL(列名) 若分页查询，count为0,应该直接返回，避免执行后面的分页语句 不得使用外键和级联 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性 数据订正，要先select，避免出现误删除 对于数据库中多个表的查询，都需要在列名前加表的别名 在表查询中，一律不使用* 不要使用resultCLass当返回参数，即使所有的属性名与数据库字段对应，也需要定义resultMap，方便配置映射关系，使字段与DO类解耦 不允许直接拿HashMap和HashTable作为查询结果输出某同学为了避免写一个resultMap,直接使用HashMap接受数据库返回结果，结果出现本地把bigint转换成long值，而由于线上数据库版本不一样，解析成BigInteger，出现问题","categories":[],"tags":[{"name":"开发记录","slug":"开发记录","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}]},{"title":"子查询的七种类型","slug":"mysql/01子查询的七种类型","date":"2019-05-10T14:55:13.000Z","updated":"2022-05-30T03:05:17.167Z","comments":true,"path":"2019/05/10/mysql/01子查询的七种类型/","link":"","permalink":"http://example.com/2019/05/10/mysql/01%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%83%E7%A7%8D%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"where 子查询查询单值查出每个栏目最新的商品(以good_id为最大为最新商品)： 1234567select cat_id,good_id,good_name from goods where good_id in(selct max(good_id) from goods group by cat_id); form 型子查询多行多列的结果集查出每个栏目最新的商品 (以 good_id 为最大为最新商品) 1234select * from (select cat_id,good_id,good_name from goods order by cat_id asc, good_id desc) as tep group by cat_id; from查出挂科 2 门及以上同学的平均分 12345678910111213# 1.先求出挂科两门以上及两门的同学select name,count(*) as gk from stu where score&lt;60 group by name having gk&gt;=2;# 2.去除多余的一行select name from (select name,count(*) as gk from stu where score&lt;60 group by name having gk&gt;=2)as tmp;# 3.最终结果select name ,avg(score) as &#x27;平均分&#x27; from stu where name in(select name from (select name,count(*) as gk from stu where score&lt;60 group by name having gk&gt;=2)as tmp)group by name; in查询年龄为 20 岁的员工部门 123select * from department where did in(SELECT did from employee where age=20); exists查询是否存在年龄大于 21 岁的员工 1select * from department where EXISTS (SELECT did from employee where age&gt;21); any查询满足条件的部门 1select * from department where did&gt; any (SELECT did from employee ); all查询满足条件的部门 1select * from department where did&gt; all(SELECT did from employee ); 比较运算符子查询查询赵四是哪个部门的 1select * from department where did= all(SELECT did from employee where name=&#x27;赵四&#x27;); 总结：where 型子查询：指把内部查询的结果作为外层查询的比较条件。from 型子查询：把内层的查询结果当成临时表，供外层 sql 再次查询。in 子查询：内层查询语句仅返回一个数据列，这个数据列的值将供外层查询语句进行比较。exists 子查询：把外层的查询结果，拿到内层，看内层是否成立，简单来说后面的返回 true, 外层（也就是前面的语句）才会执行，否则不执行。any 子查询：只要满足内层子查询中的任意一个比较条件，就返回一个结果作为外层查询条件。all 子查询：内层子查询返回的结果需同时满足所有内层查询条件。比较运算符子查询：子查询中可以使用的比较运算符如 “&gt;” “&lt;” “= ” “!=”","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]}],"categories":[],"tags":[{"name":"开发记录","slug":"开发记录","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"组件","slug":"组件","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6/"},{"name":"万融","slug":"万融","permalink":"http://example.com/tags/%E4%B8%87%E8%9E%8D/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]}